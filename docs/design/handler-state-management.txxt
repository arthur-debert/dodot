# Handler State Management Design

This document proposes a unified solution for handler state management, addressing three related issues:
- Unified state removal (TODO #3)
- Handler type registry (TODO #4)  
- Handler state directories (TODO #5)

## Problem Statement

Currently, handler state management is scattered across the codebase with:
1. Hardcoded handler type checks using switch statements
2. Centralized state directory naming in helper functions
3. Handler-specific state removal logic duplicated in multiple places

This violates SOLID principles and makes adding new handlers difficult.

## Proposed Solution

### 1. Enhanced Handler Interface

Extend the handler interface to include state management capabilities:

```go
// pkg/types/handler.go

type HandlerType int

const (
    LinkingHandlerType HandlerType = iota
    ProvisioningHandlerType
)

// HandlerMetadata provides information about a handler
type HandlerMetadata interface {
    // Type returns whether this is a linking or provisioning handler
    Type() HandlerType
    
    // StateConfig returns state storage configuration
    StateConfig() StateConfiguration
}

// StateConfiguration defines how a handler stores state
type StateConfiguration struct {
    // Directory name under the state root (empty if no state)
    Directory string
    
    // Whether state is stored per-file or per-pack
    PerFile bool
    
    // File extension for state files (if PerFile is true)
    Extension string
}

// Enhanced handler interface
type Handler interface {
    Name() string
    Metadata() HandlerMetadata
    // ... existing methods
}
```

### 2. Handler Implementations

Each handler implements the metadata interface:

```go
// pkg/handlers/symlink/symlink.go
type SymlinkHandler struct {
    // ... existing fields
}

func (h *SymlinkHandler) Metadata() HandlerMetadata {
    return &symlinkMetadata{}
}

type symlinkMetadata struct{}

func (m *symlinkMetadata) Type() HandlerType {
    return LinkingHandlerType
}

func (m *symlinkMetadata) StateConfig() StateConfiguration {
    return StateConfiguration{
        Directory: "",  // Symlinks store state differently
        PerFile:   false,
    }
}

// pkg/handlers/shell_profile/shell_profile.go  
type shellProfileMetadata struct{}

func (m *shellProfileMetadata) Type() HandlerType {
    return LinkingHandlerType
}

func (m *shellProfileMetadata) StateConfig() StateConfiguration {
    return StateConfiguration{
        Directory: "shell_profiles",
        PerFile:   true,
        Extension: ".state",
    }
}

// pkg/handlers/install/install.go
type installMetadata struct{}

func (m *installMetadata) Type() HandlerType {
    return ProvisioningHandlerType
}

func (m *installMetadata) StateConfig() StateConfiguration {
    return StateConfiguration{
        Directory: "",  // Uses provisioning system
        PerFile:   false,
    }
}
```

### 3. Registry Enhancements

Update the registry to provide type queries:

```go
// pkg/registry/registry.go

type Registry interface {
    // ... existing methods
    
    // GetHandlerType returns the type of a handler
    GetHandlerType(name string) (HandlerType, error)
    
    // GetHandlersByType returns all handlers of a specific type
    GetHandlersByType(handlerType HandlerType) []Handler
    
    // GetStateConfig returns state configuration for a handler
    GetStateConfig(name string) (StateConfiguration, error)
}

// Implementation
func (r *registry) GetHandlerType(name string) (HandlerType, error) {
    handler, err := r.Get(name)
    if err != nil {
        return 0, err
    }
    return handler.Metadata().Type(), nil
}
```

### 4. Unified State Management in DataStore

Add unified state management to the DataStore interface:

```go
// pkg/types/datastore.go

type DataStore interface {
    // ... existing methods
    
    // RemoveHandlerState removes all state for a handler in a pack
    RemoveHandlerState(packName, handlerName string) error
    
    // GetHandlerState retrieves state information
    GetHandlerState(packName, handlerName string) (HandlerState, error)
}

// pkg/datastore/filesystem.go

func (s *FilesystemStore) RemoveHandlerState(packName, handlerName string) error {
    // Get handler from registry
    handler, err := s.registry.Get(handlerName)
    if err != nil {
        return fmt.Errorf("unknown handler %s: %w", handlerName, err)
    }
    
    config := handler.Metadata().StateConfig()
    
    // Handle different state storage patterns
    switch {
    case config.Directory == "":
        // Handler doesn't use directory-based state
        return s.removeCustomState(packName, handlerName)
        
    case config.PerFile:
        // Remove all state files in handler directory
        stateDir := filepath.Join(s.stateRoot, packName, config.Directory)
        return os.RemoveAll(stateDir)
        
    default:
        // Remove single state file
        statePath := filepath.Join(s.stateRoot, packName, config.Directory)
        return os.Remove(statePath)
    }
}

// Special handling for handlers with custom state
func (s *FilesystemStore) removeCustomState(packName, handlerName string) error {
    switch handlerName {
    case "symlink":
        // Symlinks store state as actual symlinks
        return s.clearSymlinks(packName)
    case "install", "provision":
        // These use the provisioning system
        return s.clearProvisioningState(packName, handlerName)
    default:
        return nil // No state to remove
    }
}
```

### 5. Simplified Clear Executor

With the new design, the clear executor becomes much simpler:

```go
// pkg/executor/clear.go

func (e *ClearExecutor) Execute() error {
    results := []HandlerResult{}
    
    for _, handler := range e.handlers {
        // No more type checking needed!
        err := e.dataStore.RemoveHandlerState(e.pack.Name, handler.Name())
        
        result := HandlerResult{
            Handler: handler.Name(),
            Success: err == nil,
            Error:   err,
        }
        results = append(results, result)
    }
    
    return e.aggregateResults(results)
}

// No more isLinkingHandler() function needed!
// No more GetHandlerStateDir() function needed!
```

## Benefits

1. **Single Responsibility**: Each handler manages its own state configuration
2. **Open/Closed**: Easy to add new handlers without modifying existing code
3. **DRY**: No more duplicated state removal logic
4. **Type Safety**: Handler types are explicit, not string-based
5. **Testability**: Each component can be tested independently
6. **Flexibility**: Handlers can have custom state storage patterns

## Migration Path

1. **Phase 1**: Add new interfaces without breaking existing code
   - Implement HandlerMetadata interface on all handlers
   - Add new methods to registry
   - Keep existing code working

2. **Phase 2**: Implement unified state removal
   - Add RemoveHandlerState to DataStore
   - Update one handler at a time
   - Add tests for each handler

3. **Phase 3**: Remove old code
   - Delete isLinkingHandler()
   - Delete GetHandlerStateDir()
   - Remove handler-specific logic from clear.go
   - Update all callers

## Testing Strategy

1. **Unit Tests**: Test each handler's metadata implementation
2. **Integration Tests**: Test state removal for each handler type
3. **Registry Tests**: Test type queries and filtering
4. **Migration Tests**: Ensure backward compatibility during migration

## Example Usage

```go
// Query handler types through registry
handlerType, _ := registry.GetHandlerType("symlink")
if handlerType == LinkingHandlerType {
    // Handle linking behavior
}

// Get all provisioning handlers
provHandlers := registry.GetHandlersByType(ProvisioningHandlerType)

// Remove state uniformly
dataStore.RemoveHandlerState("mypack", "shell_profile")
dataStore.RemoveHandlerState("mypack", "install")  // Same interface!
```

## Future Extensions

This design enables future enhancements:
1. **State Versioning**: Add version field to StateConfiguration
2. **State Migration**: Support upgrading state between versions
3. **State Backup**: Add backup/restore capabilities
4. **Custom State Handlers**: Allow plugins to define state storage

## Conclusion

This unified design solves all three related TODOs while providing a clean, extensible architecture for handler state management. It follows SOLID principles and makes the codebase more maintainable and testable.