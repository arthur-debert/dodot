dodot Implementation and Execution
================================

1. Overview 
    
    This document covers the Go implementation of dodot. Read docs/design/overview.txxt for the conceptual reasoning.

    The execution pipeline follows these steps:
        1. Get configuration, resolve DOTFILES directory
        2. Resolve pack names to paths and validate (read access, no ignore patterns, etc.)
        3. For each pack: run the matchers to get firing triggers → slice of trigger matches and their power-ups
            a. Resolve configuration including the pack's TOML file (if present)
            b. Run triggers and accumulate which ones fire
        4. Activate power-ups → slice of actions per power-up
            a. Group trigger matches by power-up, pack, and options
            b. Run power-ups for each group and accumulate actions
        5. Plan actions → slice of synthetic file system operations to run
            a. Transform actions into synthfs operations
        6. Execute: actually run these changes
            a. Execute all operations through the synthfs library

    This covers the implementation for triggers, actions, and power-ups.


2. Dependencies
    
    We use libraries that handle abstract lower-level parts of the problem:

    - synthfs [https://github.com/arthur-debert/go-synthfs]
      Created specifically for this problem. Provides an API for creating file system operations
      and a runner to execute them, plus visualization facilities.
      Local paths: local/third-parties/go-synthfs

    - koanf [https://github.com/knadh/koanf] 
      Allows declaring a chain of configuration sources (files, env vars, command line options) 
      and returns a unified configuration merged in the correct order.

    - cobra [https://github.com/spf13/cobra]
      Industry-standard CLI framework for Go applications. Provides command parsing,
      flag management, and help generation.

    - zerolog [https://github.com/rs/zerolog]
      High-performance structured logging library with minimal allocations.


3. Design Principles

    3.1. Idiomatic Go
        
        We follow Go best practices and idioms throughout:
        - Explicit error handling with error return values
        - Interface-based design for extensibility
        - Minimal use of reflection
        - Clear package boundaries and dependencies
        - Effective use of goroutines for concurrent operations where appropriate

    3.2. API Design

        The API follows Go conventions:

            package core

            import "github.com/dodot/pkg/types"

            func GetPackCandidates(dotfilesRoot string) ([]string, error)
            func GetPacks(candidates []string) ([]types.Pack, error)
            func GetFiringTriggers(packs []types.Pack, matchers []types.Matcher) ([]types.TriggerMatch, error)
            func GetActions(triggerMatches []types.TriggerMatch, powerups types.PowerupRegistry) ([]types.Action, error)
            func GetFsOps(actions []types.Action) ([]synthfs.Operation, error)

        Functions accept options through functional options pattern where appropriate:
            GetFiringTriggers(packs, WithMatchers(customMatchers))

    3.3. CLI Isolation

        The entire system implements pure business logic. The core packages only work with
        Go types, not shell arguments. Nothing prints to stdout/stderr directly.

        The cmd/dodot/main.go file handles argument parsing, validation, and calling appropriate 
        commands. Beyond that point, there is no CLI dependency.

    3.4. Data Types

        Core entities are defined as interfaces in pkg/types:
        - Trigger: Interface for matching logic 
        - PowerUp: Interface for processing logic
        - Matcher: Struct connecting triggers to power-ups
        - Action: Struct for high-level operations
        - Operation: synthfs operation types

    3.5. Error Handling

        We use typed errors with structured error codes:

            type DodotError struct {
                Code    ErrorCode
                Message string
                Details map[string]interface{}
            }

        This allows tests to verify error codes rather than brittle string matching,
        and enables future i18n support.

        
4. Implementation Strategy

    4.1. Deploy Command First
        
        Since the core use case is the deploy command (everything else supports it), we implement 
        it end-to-end first, including file system mutations and CLI.

    4.2. Reducing Scope
        
        a. Core Power-ups

            Instead of implementing all power-ups at once, we work on a smaller subset that 
            exercises all necessary functionality:

            Initial power-ups:
                - symlink power-up (to user home)
                - profile power-up (add things to shell)
                - bin power-up (add paths)

            These exercise most required triggers and actions without being extensive.

        b. No Customization Initially

            The koanf library allows us to normalize user customization in a clean way. 
            Initially we work without customization but keep interfaces for GetMergedConfig(). 
            Later we can change these to actually use koanf.

        c. Registry System

            All matchers, triggers, actions, and power-ups will be user-extensible through 
            a registry system. 

                package registry

                type Registry[T any] interface {
                    Register(name string, item T) error
                    Get(name string) (T, error)
                    Remove(name string) error
                    List() []string
                }

            The core dodot object will have:
            
                type Libraries struct {
                    Triggers  Registry[Trigger]
                    Actions   Registry[Action]
                    PowerUps  Registry[PowerUp]
                }
            
            Each category's init() function registers its components.

    4.3. Project Layout

        Proposed structure following standard Go layout:

        dodot/
        ├── cmd/
        │   └── dodot/
        │       └── main.go             # CLI entry point
        ├── pkg/
        │   ├── core/                   # Core pipeline functions
        │   ├── types/                  # Type definitions and interfaces
        │   ├── triggers/               # Trigger implementations
        │   ├── powerups/               # PowerUp implementations
        │   ├── matchers/               # Matcher system
        │   ├── actions/                # Action to operation conversion
        │   ├── config/                 # Configuration handling
        │   ├── registry/               # Generic registry implementation
        │   └── logging/                # Logging utilities
        ├── internal/                   # Internal packages
        └── docs/                       # Documentation


