dodot Implementation and Execution
================================

1. Overview 
    
    This document covers the Go implementation of dodot. Read docs/design/overview.txxt for the conceptual reasoning.

    The execution pipeline follows these steps:
        1. Get configuration, resolve DOTFILES directory
        2. Resolve pack names to paths and validate (read access, no ignore patterns, etc.)
        3. For each pack: run the matchers to get firing triggers → slice of trigger matches and their power-ups
            a. Resolve configuration including the pack's TOML file (if present)
            b. Run triggers and accumulate which ones fire
        4. Activate power-ups → slice of actions per power-up
            a. Group trigger matches by power-up, pack, and options
            b. Run power-ups for each group and accumulate actions
        5. Plan actions → slice of synthetic file system operations to run
            a. Transform actions into synthfs operations
        6. Execute: actually run these changes
            a. Execute all operations through the synthfs library

    This covers the implementation for triggers, actions, and power-ups.


2. Dependencies
    
    We use libraries that handle abstract lower-level parts of the problem:

    - synthfs [https://github.com/arthur-debert/go-synthfs]
      Created specifically for this problem. Provides an API for creating file system operations
      and a runner to execute them, plus visualization facilities.
      Local paths: local/third-parties/go-synthfs

    - koanf [https://github.com/knadh/koanf] 
      Allows declaring a chain of configuration sources (files, env vars, command line options) 
      and returns a unified configuration merged in the correct order.

    - cobra [https://github.com/spf13/cobra]
      Industry-standard CLI framework for Go applications. Provides command parsing,
      flag management, and help generation.

    - zerolog [https://github.com/rs/zerolog]
      High-performance structured logging library with minimal allocations.


3. Design Principles

    3.1. Idiomatic Go
        
        We follow Go best practices and idioms throughout:
        - Explicit error handling with error return values
        - Interface-based design for extensibility
        - Minimal use of reflection
        - Clear package boundaries and dependencies
        - Effective use of goroutines for concurrent operations where appropriate

    3.2. API Design

        The API follows Go conventions:

            package core

            import "github.com/dodot/pkg/types"

            func GetPackCandidates(dotfilesRoot string) ([]string, error)
            func GetPacks(candidates []string) ([]types.Pack, error)
            func GetFiringTriggers(packs []types.Pack, matchers []types.Matcher) ([]types.TriggerMatch, error)
            func GetActions(triggerMatches []types.TriggerMatch, powerups types.PowerupRegistry) ([]types.Action, error)
            func GetFsOps(actions []types.Action) ([]synthfs.Operation, error)

        Functions accept options through functional options pattern where appropriate:
            GetFiringTriggers(packs, WithMatchers(customMatchers))

    3.3. CLI Isolation

        The entire system implements pure business logic. The core packages only work with
        Go types, not shell arguments. Nothing prints to stdout/stderr directly.

        The cmd/dodot/main.go file handles argument parsing, validation, and calling appropriate 
        commands. Beyond that point, there is no CLI dependency.

    3.4. Data Types

        Core entities are defined as interfaces in pkg/types:
        - Trigger: Interface for matching logic 
        - PowerUp: Interface for processing logic
        - Matcher: Struct connecting triggers to power-ups
        - Action: Struct for high-level operations
        - Operation: synthfs operation types

    3.5. Error Handling

        We use typed errors with structured error codes:

            type DodotError struct {
                Code    ErrorCode
                Message string
                Details map[string]interface{}
            }

        This allows tests to verify error codes rather than brittle string matching,
        and enables future i18n support.

        
4. Implementation Strategy

    4.1. Deploy Command First
        
        Since the core use case is the deploy command (everything else supports it), we implement 
        it end-to-end first, including file system mutations and CLI.

    4.2. Reducing Scope
        
        a. Core Power-ups

            Instead of implementing all power-ups at once, we work on a smaller subset that 
            exercises all necessary functionality:

            Initial power-ups:
                - symlink power-up (to user home)
                - profile power-up (add things to shell)
                - bin power-up (add paths)

            These exercise most required triggers and actions without being extensive.

        b. No Customization Initially

            The koanf library allows us to normalize user customization in a clean way. 
            Initially we work without customization but keep interfaces for GetMergedConfig(). 
            Later we can change these to actually use koanf.

        c. Registry System

            All matchers, triggers, actions, and power-ups will be user-extensible through 
            a registry system. 

                package registry

                type Registry[T any] interface {
                    Register(name string, item T) error
                    Get(name string) (T, error)
                    Remove(name string) error
                    List() []string
                }

            The core dodot object will have:
            
                type Libraries struct {
                    Triggers  Registry[Trigger]
                    Actions   Registry[Action]
                    PowerUps  Registry[PowerUp]
                }
            
            Each category's init() function registers its components.

    4.3. Project Layout

        Proposed structure following standard Go layout:

        dodot/
        ├── cmd/
        │   └── dodot/
        │       └── main.go             # CLI entry point
        ├── pkg/
        │   ├── core/                   # Core pipeline functions
        │   ├── types/                  # Type definitions and interfaces
        │   ├── triggers/               # Trigger implementations
        │   ├── powerups/               # PowerUp implementations
        │   ├── matchers/               # Matcher system
        │   ├── actions/                # Action to operation conversion
        │   ├── config/                 # Configuration handling
        │   ├── registry/               # Generic registry implementation
        │   └── logging/                # Logging utilities
        ├── internal/                   # Internal packages
        └── docs/                       # Documentation

5. Implementation Phases and Deliverables

    Phase 1: Foundation - "Bedrock"
        
        Goal: Establish all foundational pieces for controlled, incremental development.
        
        Deliverable 1.1: Project Structure
        Tasks:
        - Create directory layout as specified in 4.3
        - Initialize go module with go mod init
        - Create Makefile with common tasks
        - Set up .gitignore for Go projects
        
        Success Criteria:
        - ✓ All directories and placeholder files created
        - ✓ Module structure follows Go conventions
        - ✓ go mod tidy runs successfully
        - ✓ Git repository initialized and configured

        Deliverable 1.2: Dependencies Setup
        Tasks:
        - Add core dependencies to go.mod
        - Install and configure synthfs dependency
        - Install and configure koanf dependency
        - Set up development tools (golangci-lint, etc.)
        
        Success Criteria:
        - ✓ go.mod properly configured with all dependencies
        - ✓ All dependencies resolve with go mod download
        - ✓ Development environment functional

        Deliverable 1.3: Testing Framework
        Tasks:
        - Set up Go testing structure
        - Configure testify for assertions
        - Create test helpers package
        - Implement basic test examples
        
        Success Criteria:
        - ✓ go test ./... runs successfully
        - ✓ Test coverage reporting configured
        - ✓ Sample tests pass

        Deliverable 1.4: Logging
        Tasks: 
        - Implement centralized logging with zerolog
        - Configure logging to both stdout and XDG_STATE_HOME/dodot/dodot.log
        - Default log level is WARN
        - CLI flags -v (info), -vv (debug), -vvv (trace)
        - Integrate logging with cobra command flags
        - From now on all implementations should include logging
        
        Success Criteria:
        - ✓ Logging package functional
        - ✓ Log levels work correctly
        - ✓ File and console output working

        Deliverable 1.5: Registry System
        Tasks:
        - Implement generic registry system with type parameters
        - Create registry tests
        - Validate registry Register/Get/Remove/List functionality
        
        Success Criteria:
        - ✓ Registry system functional with full API
        - ✓ Registry tests pass
        - ✓ Type-safe registry operations

        Deliverable 1.6: Error Handling Foundation
        Tasks:
        - Implement error handling system with error codes
        - Create error type definitions
        - Add error wrapping utilities
        - Add error handling tests
        
        Success Criteria:
        - ✓ Error handling system operational
        - ✓ Error types defined and tested
        - ✓ Error wrapping preserves context

    Phase 2: Core Pipeline - "Backbone"
    
        Goal: Implement the core execution pipeline stages and data flow.
        
        Deliverable 2.1: Data Type Definitions
        Tasks:
        - Create interfaces for Trigger, PowerUp, Action
        - Implement Pack, TriggerMatch, Matcher structs
        - Add validation methods
        - Create type conversion utilities
        
        Success Criteria:
        - ✓ All core types defined in pkg/types
        - ✓ Interface contracts clear
        - ✓ Validation methods working

        Deliverable 2.2: Pack Discovery
        Tasks:
        - Implement basic pack discovery logic
        - Create pack validation functions
        - Implement pack candidate filtering
        - Add pack discovery tests
        
        Success Criteria:
        - ✓ Can discover potential packs in directory
        - ✓ Pack validation logic functional
        - ✓ Pack filtering works correctly

        Deliverable 2.3: Core Pipeline Skeleton
        Tasks:
        - Implement pkg/core/packs.go
        - Implement pkg/core/triggers.go
        - Implement pkg/core/actions.go
        - Implement pkg/core/operations.go
        - Create pipeline integration
        
        Success Criteria:
        - ✓ All pipeline stages have implementations
        - ✓ Data flows correctly between stages
        - ✓ Pipeline integration functional

        Deliverable 2.4: Registry Integration
        Tasks:
        - Integrate registry system with pipeline stages
        - Implement Libraries struct with registries
        - Create registry loading for triggers/actions/powerups
        - Add registry integration tests
        
        Success Criteria:
        - ✓ Registry system integrated with pipeline
        - ✓ Libraries initialization working
        - ✓ Integration tests pass

    Phase 3: Core Triggers & Power-ups - "Workhorses"
        
        Goal: Implement essential triggers and power-ups to validate the complete system.
        
        Deliverable 3.1: File-based Triggers
        Tasks:
        - Implement FileNameTrigger with glob support
        - Implement DirectoryTrigger
        - Implement ExtensionTrigger
        - Add comprehensive trigger tests
        
        Success Criteria:
        - ✓ All file-based triggers functional
        - ✓ Glob patterns work correctly
        - ✓ Trigger tests pass with real files

        Deliverable 3.2: Basic Matcher System
        Tasks:
        - Implement basic matcher configuration
        - Create trigger-to-powerup connection logic
        - Implement matcher validation
        - Add matcher system tests
        
        Success Criteria:
        - ✓ Matcher system connects triggers to power-ups
        - ✓ Matcher configuration validates correctly
        - ✓ Matcher tests pass

        Deliverable 3.3: Symlink Power-up
        Tasks:
        - Implement symlink power-up for home directory
        - Create symlink action generation
        - Add symlink validation logic
        - Implement symlink tests
        
        Success Criteria:
        - ✓ Symlink power-up generates correct actions
        - ✓ Symlink validation prevents conflicts
        - ✓ Symlink tests pass

        Deliverable 3.4: Profile Power-up
        Tasks:
        - Implement profile power-up for shell integration
        - Create shell profile detection
        - Implement profile modification actions
        - Add profile power-up tests
        
        Success Criteria:
        - ✓ Profile power-up detects shell types
        - ✓ Profile modification actions generated correctly
        - ✓ Profile tests pass

        Deliverable 3.5: Bin Power-up
        Tasks:
        - Implement bin power-up for PATH management
        - Create PATH modification logic
        - Implement bin directory handling
        - Add bin power-up tests
        
        Success Criteria:
        - ✓ Bin power-up handles PATH modifications
        - ✓ Bin directory operations work correctly
        - ✓ Bin tests pass

    Phase 4: Operation Execution - "Executor"
        
        Goal: Implement and test the final operations execution with confidence in core functionality.
        
        Deliverable 4.1: Action-to-Operation Conversion
        Tasks:
        - Implement action-to-operation conversion logic
        - Create operation type mapping
        - Add operation validation
        - Implement conversion tests
        
        Success Criteria:
        - ✓ Actions convert to synthfs operations correctly
        - ✓ Operation types mapped properly
        - ✓ Conversion tests pass

        Deliverable 4.2: synthfs Integration
        Tasks:
        - Integrate synthfs library for operations
        - Add synthfs configuration management
        - Create operation batching for efficiency
        
        Success Criteria:
        - ✓ synthfs integration functional
        - ✓ Operations execute through synthfs
        - ✓ Batching improves performance

        Deliverable 4.3: Dry-run Support
        Tasks:
        - Implement dry-run mode for operations
        - Create operation preview functionality
        - Add dry-run output formatting
        - Implement dry-run tests
        
        Success Criteria:
        - ✓ Dry-run mode works correctly
        - ✓ Operation preview shows expected changes
        - ✓ Dry-run tests pass

        Deliverable 4.4: Operation Execution
        Tasks:
        - Implement operation execution with context
        - Add progress reporting
        - Create integration tests
        
        Success Criteria:
        - ✓ Operations execute successfully
        - ✓ Progress reporting accurate
        - ✓ Integration tests pass
        
        Deliverable 4.5: Error Handling and Rollback
        Tasks:
        - Implement operation error handling
        - Create rollback functionality
        - Add error recovery mechanisms
        - Implement error handling tests
        
        Success Criteria:
        - ✓ Operation errors handled gracefully
        - ✓ Rollback functionality works
        - ✓ Error handling tests pass

    Phase 5: CLI Interface - "Commander"
        
        Goal: Create the command-line interface that bridges user input to business logic.
        
        Deliverable 5.1: Cobra Setup
        Tasks:
        - Implement cmd/dodot/main.go with cobra
        - Create root command with global flags
        - Add version command
        - Configure help system
        
        Success Criteria:
        - ✓ CLI framework operational
        - ✓ Global flags working
        - ✓ Help system comprehensive

        Deliverable 5.2: Deploy Command
        Tasks:
        - Create deploy command
        - Implement deploy command logic
        - Connect CLI to business logic
        - Add deploy command tests
        
        Success Criteria:
        - ✓ Deploy command functional
        - ✓ CLI-to-business-logic bridge works
        - ✓ Deploy tests pass

        Deliverable 5.3: Output Formatting
        Tasks:
        - Implement user-friendly output formatting
        - Create progress indicators
        - Add verbose and quiet modes
        - Implement output tests
        
        Success Criteria:
        - ✓ Output formatting user-friendly
        - ✓ Progress indicators functional
        - ✓ Output mode switching works

        Deliverable 5.4: End-to-End Integration
        Tasks:
        - Integrate all components for working `dodot deploy`
        - Perform end-to-end testing
        - Fix integration issues
        - Validate complete workflow
        
        Success Criteria:
        - ✓ `dodot deploy` command works end-to-end
        - ✓ File system mutations execute correctly
        - ✓ Integration issues resolved

    Phase 6: Supporting Commands - "Toolkit"

        Goal: Implement auxiliary commands that support the deploy workflow.

        Deliverable 6.1: List Command
        Tasks:
        - Implement list command (show available packs)
        - Create pack discovery and formatting
        - Add pack status indicators
        - Implement list tests
        
        Success Criteria:
        - ✓ List command shows available packs
        - ✓ Pack information displayed clearly
        - ✓ List tests pass

        Deliverable 6.2: Completion Command
        Tasks:
        - Implement shell completion generation
        - Support bash, zsh, fish completions
        - Add completion installation instructions
        - Test completions
        
        Success Criteria:
        - ✓ Completion generation works
        - ✓ All shells supported
        - ✓ Completions functional

        Deliverable 6.3: Man Page Generation
        Tasks:
        - Implement man page generation
        - Create comprehensive documentation
        - Add man page installation
        - Test man pages
        
        Success Criteria:
        - ✓ Man pages generated correctly
        - ✓ Documentation comprehensive
        - ✓ Man pages render properly

        Deliverable 6.4: Debug Support
        Tasks:
        - Add debug command for diagnostics
        - Implement configuration dumping
        - Create system information gathering
        - Add debug tests
        
        Success Criteria:
        - ✓ Debug information comprehensive
        - ✓ Configuration dump helpful
        - ✓ Debug tests pass

    Phase 7: Advanced Features - "Powerhouse"

        Goal: Expand the system with additional power-ups and triggers.

        Deliverable 7.1: Advanced Triggers
        Tasks:
        - Implement ContentTrigger (file content matching)
        - Implement CombinationTrigger (AND/OR logic)
        - Add advanced trigger configuration
        - Implement advanced trigger tests
        
        Success Criteria:
        - ✓ Content-based file matching operational
        - ✓ Complex trigger combinations supported
        - ✓ Advanced trigger tests pass

        Deliverable 7.2: Brew Power-up
        Tasks:
        - Implement brew power-up (Brewfile support)
        - Create Brewfile parsing
        - Add brew installation actions
        - Implement brew tests
        
        Success Criteria:
        - ✓ Brew power-up processes Brewfiles
        - ✓ Brew installation actions work
        - ✓ Brew tests pass

        Deliverable 7.3: Script Runner Power-up
        Tasks:
        - Implement script_runner power-up
        - Create script execution with context
        - Add script output handling
        - Implement script runner tests
        
        Success Criteria:
        - ✓ Script execution working safely
        - ✓ Script output captured and handled
        - ✓ Script runner tests pass

        Deliverable 7.4: Advanced Matcher Configurations
        Tasks:
        - Implement advanced matcher configurations
        - Create matcher priority systems
        - Add conditional matcher logic
        - Implement advanced matcher tests
        
        Success Criteria:
        - ✓ Advanced matcher configurations functional
        - ✓ Matcher priority systems work
        - ✓ Advanced matcher tests pass

    Phase 8: Customization System - "Configurator"
        
        Goal: Implement comprehensive customization through configuration layers.
        
        Deliverable 8.1: Configuration File Support
        Tasks:
        - Implement user-wide customization (~/.config/dodot/config.toml)
        - Implement pack customization (.dodot.toml per pack)
        - Add TOML parsing with pelletier/go-toml
        - Implement configuration tests
        
        Success Criteria:
        - ✓ Configuration files parsed correctly
        - ✓ User and pack customization working
        - ✓ Configuration tests pass

        Deliverable 8.2: Environment Variable Support
        Tasks:
        - Implement environment variable support (DODOT_*)
        - Create environment variable parsing
        - Add environment variable precedence
        - Implement environment tests
        
        Success Criteria:
        - ✓ Environment variables processed correctly
        - ✓ Variable precedence handled properly
        - ✓ Environment tests pass

        Deliverable 8.3: Koanf Integration
        Tasks:
        - Integrate koanf library for configuration merging
        - Implement configuration hierarchy
        - Add configuration conflict resolution
        - Implement koanf integration tests
        
        Success Criteria:
        - ✓ koanf integration seamless
        - ✓ Configuration hierarchy functional
        - ✓ Integration tests pass

        Deliverable 8.4: Configuration Validation
        Tasks:
        - Implement configuration validation
        - Create configuration schema validation
        - Add helpful error messages
        - Implement validation tests
        
        Success Criteria:
        - ✓ Configuration validation comprehensive
        - ✓ Error messages actionable and clear
        - ✓ Validation tests pass



6. Technical Implementation Notes

    6.1. File System Safety
        
        All file system operations go through synthfs for safety:
        - Validation before execution
        - Dry-run capability
        - Transactional rollback where possible
        - Atomic operations when available

    6.2. Configuration Hierarchy
        
        Configuration merging order (koanf library):
        1. Built-in defaults
        2. Global ~/.config/dodot/config.toml  
        3. Pack-specific .dodot.toml
        4. Environment variables (DODOT_*)
        5. Command line arguments

    6.3. Error Handling Strategy
        
        Fail fast with clear messages:
        - Validate everything upfront
        - Provide actionable error messages
        - Support continuing on non-critical errors
        - Always allow dry-run for safety

    6.4. Testing Strategy
        
        Test each layer independently:
        - Unit tests for pure functions, with tables

    6.5. Concurrency Considerations
        
        Use Go's concurrency primitives wisely:
        - Concurrent pack processing where safe
        - Synchronization for shared resources
        - Context-based cancellation
        - Graceful shutdown handling

7. Success Criteria by Deliverable

    Each deliverable has specific, measurable success criteria that must be met before proceeding 
    to the next deliverable. This ensures steady progress and prevents accumulation of technical debt.

    Phase 1 (Foundation): Solid foundation enables controlled development
    Phase 2 (Core Pipeline): Pipeline processes data correctly end-to-end
    Phase 3 (Workhorses): Essential functionality works with real files
    Phase 4 (Executor): File system operations execute safely and correctly
    Phase 5 (Commander): Users can run `dodot deploy` successfully
    Phase 6 (Toolkit): Complete command suite supports user workflow
    Phase 7 (Powerhouse): Advanced features expand system capabilities
    Phase 8 (Configurator): Full customization system operational
    Phase 9 (Production): System ready for public release

This implementation plan provides a clear roadmap with granular deliverables, each with specific 
success criteria. The numbered deliverable system (e.g., Phase 1.1, 1.2, etc.) allows for 
precise tracking of progress and makes it easy to communicate current status and next steps.
