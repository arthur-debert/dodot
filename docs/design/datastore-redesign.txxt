# DataStore Redesign

This document outlines the redesign needed to improve the DataStore architecture.

## Current Problems

### 1. Too Many Responsibilities
The DataStore interface has 20+ methods and knows about specific handler types:
- Symlink operations
- Path management
- Shell profile handling
- Provisioning state
- Brew status

### 2. Handler-Specific Methods
```go
// Current problematic design:
AddToPath(pack, dirPath string) error
AddToShellProfile(pack, scriptPath string) error
GetSymlinkStatus(pack, sourceFile string) (Status, error)
GetPathStatus(pack, dirPath string) (Status, error)
GetShellProfileStatus(pack, scriptPath string) (Status, error)
GetBrewStatus(pack, brewfilePath, checksum string) (Status, error)
```

### 3. Inconsistent Abstractions
- Some handlers use generic methods (RemoveState)
- Others have specific methods (AddToPath)
- Provisioning has its own subsystem

## Better Design

### 1. Single Responsibility - Just Store State
```go
type DataStore interface {
    // State storage
    Put(key string, value []byte) error
    Get(key string) ([]byte, error)
    Delete(key string) error
    List(prefix string) ([]string, error)
    
    // Transactions (optional)
    Begin() Transaction
}
```

### 2. Handler-Owned Storage Logic
Each handler manages its own state structure:
```go
type Handler interface {
    // Handler decides how to store/retrieve its state
    SaveState(store DataStore, pack string, state interface{}) error
    LoadState(store DataStore, pack string) (interface{}, error)
    ClearState(store DataStore, pack string) error
}
```

### 3. Separate Status from Storage
```go
// Status is a query concern, not storage
type StatusChecker interface {
    GetStatus(pack, resource string) (Status, error)
}

// Each handler implements its own status logic
type SymlinkHandler struct{}
func (h *SymlinkHandler) GetStatus(pack, file string) (Status, error) {
    // Check if symlink exists, is valid, etc.
}
```

### 4. Remove Business Logic from Storage
Instead of:
```go
dataStore.AddToPath(pack, dir)  // Does too much
```

Do:
```go
// Handler decides what to store
pathList := handler.LoadPaths(dataStore, pack)
pathList = append(pathList, dir)
handler.SavePaths(dataStore, pack, pathList)
```

## Migration Path

### Phase 1: Add Abstraction Layer âœ…
Already started with generic StoreState/RemoveState/GetState methods

### Phase 2: Move Logic to Handlers
```go
// Instead of DataStore.AddToPath()
type PathHandler struct{}
func (h *PathHandler) AddPath(store DataStore, pack, dir string) error {
    key := fmt.Sprintf("pack:%s:paths", pack)
    // Handler owns the storage format
    paths := h.loadPaths(store, key)
    paths = append(paths, dir)
    return store.Put(key, h.encodePaths(paths))
}
```

### Phase 3: Simplify DataStore to KV Store
- Remove all handler-specific methods
- Keep only generic storage operations
- Let handlers own their data formats

### Phase 4: Add Advanced Features
- Transactions for atomic updates
- Watching for changes
- Backup/restore capabilities

## Benefits

1. **Extensibility**: New handlers just work, no DataStore changes needed
2. **Testability**: Mock a simple KV store instead of 20+ methods  
3. **Flexibility**: Handlers can change storage format without affecting others
4. **Clarity**: DataStore does one thing well - stores data
5. **SOLID Principles**: Follows Single Responsibility and Open/Closed principles

## Example: Symlink Handler Refactored

Before (DataStore knows about symlinks):
```go
dataStore.Link(pack, source)
```

After (Handler owns its logic):
```go
type SymlinkHandler struct{}

func (h *SymlinkHandler) CreateLink(store DataStore, pack, source string) error {
    // Handler decides storage format
    key := fmt.Sprintf("pack:%s:symlinks:%s", pack, source)
    
    // Handler decides what to store
    linkData := LinkRecord{
        Source: source,
        Target: h.computeTarget(source),
        Created: time.Now(),
    }
    
    // Store using generic interface
    return store.Put(key, json.Marshal(linkData))
}
```

## Implementation Notes

### Key Patterns
1. **Namespace Keys**: Use consistent key patterns like `pack:NAME:handler:RESOURCE`
2. **Atomic Operations**: Use transactions for multi-key updates
3. **Migration Support**: Keep old methods during transition, mark as deprecated
4. **Handler Registry**: Handlers register their storage needs

### Storage Backends
The simple KV interface allows multiple backends:
- Filesystem (current)
- SQLite (for better queries)
- etcd/consul (for distributed setups)
- In-memory (for testing)

## Conclusion

This redesign transforms the DataStore from a "knows everything" monolith into a simple, focused storage layer. Handlers become responsible for their own data management, leading to better separation of concerns and easier maintenance.