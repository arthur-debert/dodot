                   dodot Architecture

This document provides technical implementation details about dodot's
architecture. For concept definitions and rationale, see
10_understanding-dodot.txxt.

Processing Pipeline
-------------------

When you run a dodot command, this is what happens:

1. Discovery Phase:
   • Scan all packs to find files and directories.
   • Load pack configurations from `.dodot.toml` files.

2. Trigger Matching Phase:
   • Test each file against configured triggers (e.g., `filename`, `extension`).
   • Create `TriggerMatch` objects for files that match, linking them to a power-up.

3. Action Generation Phase:
   • Each power-up (e.g., `symlink`, `shell_profile`) processes its `TriggerMatch` objects.
   • The power-up generates high-level `Actions` that describe an intent, such as "link this file" or "source this script".

4. Operation Planning Phase:
   • `Actions` are converted into low-level, concrete `Operations`. An `Operation` is a specific task, like `CreateSymlink` or `WriteFile`.
   • This plan is created without yet touching the filesystem, enabling dry runs.

5. Execution Phase:
   • A specialized executor (powered by the `go-synthfs` library) safely executes the planned `Operations`.
   • It handles creating directories, writing files, and setting up symlinks in the correct order.

Implementation Details
----------------------

Trigger Types:
• FileNameTrigger - Uses glob patterns for name matching
• DirectoryTrigger - Matches on directory names
• ExtensionTrigger - Suffix-based matching
• RegexTrigger - Full regex pattern matching (planned)

Each trigger type implements the `Trigger` interface with a single
`Match(path string) bool` method.

Power-Up Implementation:
Power-ups implement the `PowerUp` interface:
```
type PowerUp interface {
    Name() string
    Process(matches []TriggerMatch) ([]Action, error)
}
```

The Process method must be pure - same inputs always produce same outputs.
This enables testing, caching, and predictable behavior.

Registry System
---------------

All components (triggers and power-ups) are registered in a type-safe
registry system. This enables extensibility—new triggers and power-ups can
be added without modifying the core `dodot` code.

The registry uses Go's init() functions for automatic registration:
```
func init() {
    registry.RegisterPowerUp("symlink", NewSymlinkPowerUp)
    registry.RegisterTrigger("filename", NewFileNameTrigger)
}
```

This approach ensures all components are available before main() runs.

File System Safety
------------------

dodot uses a layered approach to filesystem operations:

1. Pure Functions:
   • Power-ups are pure functions (same input → same output).
   • No side effects during action generation.
   • Easy to test and reason about.

2. Synthetic Filesystem:
   • All operations go through the `go-synthfs` library.
   • Operations are validated before execution.
   • The library automatically handles dependencies (e.g., creating a directory before placing a file in it).

3. Operation Descriptions:
   • The core pipeline produces a list of `Operations`.
   • This list is just data, which enables powerful features like dry-run validation.

Benefits of This Architecture
-----------------------------

Separation of Concerns:
• Triggers focus only on file detection.
• Power-ups focus only on generating high-level intents (`Actions`).
• The core engine handles planning (`Operations`).
• The executor handles the safety of writing to disk.

Extensibility:
• New triggers can be used with existing power-ups.
• New power-ups can work with existing triggers.
• The registry system enables a plugin-like architecture.

Testability:
• Each component can be tested in isolation.
• Pure functions enable predictable testing.
• No filesystem dependencies in the core logic.

Safety:
• No direct filesystem operations in application code.
• Validation occurs before any changes are made.
• The executor library provides safe, transactional-like behavior.

Predictability:
• Same inputs always produce the same outputs.
• Clear data flow through the pipeline.
• Easy to debug and understand.

Configuration Flow
------------------

Configuration is resolved in this order:
1. Default matchers (built into dodot).
2. Global configuration files.
3. Pack-specific `.dodot.toml` files.
4. Command-line overrides.

This allows fine-grained control while maintaining sensible defaults.

Pack Processing
---------------

Each pack is processed independently:
1. Load pack configuration (`.dodot.toml` if present).
2. Apply ignore rules from `.dodotignore` files.
3. Run the trigger/action/operation pipeline for all files in the pack.

Multiple packs can be processed in parallel since they are independent.

Action to Operation Conversion
------------------------------

The DirectExecutor converts Actions to synthfs Operations:
• Link actions → CreateSymlink operations (with parent dir creation)
• Write actions → CreateFile operations
• PathAdd actions → CreateSymlink + AppendFile operations
• Run actions → Custom operations with command execution

Each conversion handles edge cases like existing files, missing directories,
and permission issues.

Error Handling
--------------

Errors are handled at appropriate levels:
• Trigger errors - Skip individual files, continue processing.
• Power-up errors - Fail the power-up, continue with others.
• Execution errors - Stop processing and report the failure.

This provides graceful degradation while preventing partial deployments.

Error Codes:
All errors use structured error codes (not just messages) for stable testing:
```
errors.New(errors.ErrFileAccess, "permission denied")
errors.New(errors.ErrActionInvalid, "missing target path")
```

Run-Once Mechanism
------------------

For power-ups like `install` and `homebrew`, a sentinel file system prevents
repeated execution:
1. Before execution, check for sentinel file with matching checksum
2. If found and checksum matches, skip execution
3. After successful execution, write sentinel with current file checksum
4. If source file changes, checksum mismatch triggers re-execution

Sentinel files are stored in:
• ~/.local/share/dodot/install/sentinels/<pack>
• ~/.local/share/dodot/homebrew/<pack>

Performance Considerations
--------------------------

• Parallel pack processing when using --all flag
• File operations batched through synthfs for efficiency
• Registry lookups are O(1) using Go maps
• Minimal file I/O during discovery phase
• Lazy loading of pack configurations