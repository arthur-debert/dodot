                   dodot Architecture

This document provides technical implementation details about dodot's
architecture. For concept definitions and rationale, see
10_understanding-dodot.txxt.

Processing Pipeline
-------------------

When you run a dodot command, this is what happens:

1. Discovery Phase:
   • Scan all packs to find files and directories.
   • Load pack configurations from `.dodot.toml` files.

2. Trigger Matching Phase:
   • Test each file against configured triggers (e.g., `filename`, `extension`).
   • Create `TriggerMatch` objects for files that match, linking them to a handler.

3. Action Generation Phase:
   • Each handler (e.g., `symlink`, `shell`) processes its `TriggerMatch` objects.
   • The handler generates high-level `Actions` that describe an intent, such as "link this file" or "source this script".

4. Execution Phase:
   • Actions are self-contained and know how to execute themselves.
   • Each action type (LinkAction, RunScriptAction, etc.) implements its own Execute method.
   • Actions use the DataStore interface to perform filesystem operations safely.
   • The executor coordinates action execution and tracks results.

State Management Philosophy
---------------------------

Unlike traditional dotfile managers, dodot uses the filesystem itself as its
state database. Instead of maintaining separate metadata files, dodot stores
state through an intermediate link layer in the XDG data directory.

Key principles:
• State is represented through filesystem structures, not data files
• The existence of symlinks IS the state - no synchronization needed
• Running `ls -la` tells you everything about dodot's state
• The system is self-describing and resilient to corruption

This design ensures:
• No divergence between actual state and recorded state
• Easy debugging - broken links are immediately visible
• Safe to delete and recreate without losing critical information
• No parsing, no corruption, just filesystem operations

The intermediate link layer serves multiple purposes:
• Provides indirection for graceful handling of removed source files
• Enables state querying without separate metadata
• Allows dodot to detect and warn about broken configurations
• Makes the entire system observable with standard Unix tools

Implementation Details
----------------------

Trigger Types:
• FileNameTrigger - Uses glob patterns for name matching
• DirectoryTrigger - Matches on directory names
• ExtensionTrigger - Suffix-based matching
• RegexTrigger - Full regex pattern matching (planned)

Each trigger type implements the `Trigger` interface with a single
`Match(path string) bool` method.

Handler Implementation:
Handlers implement either `LinkingHandler` or `ProvisioningHandler` interface:
```
type LinkingHandler interface {
    Name() string
    ProcessLinking(matches []TriggerMatch) ([]LinkingAction, error)
}

type ProvisioningHandler interface {
    Name() string
    ProcessProvisioning(matches []TriggerMatch) ([]ProvisioningAction, error)
}
```

The Process methods must be pure - same inputs always produce same outputs.
This enables testing, caching, and predictable behavior.

Registry System
---------------

All components (triggers and handlers) are registered in a type-safe
registry system. This enables extensibility—new triggers and handlers can
be added without modifying the core `dodot` code.

The registry uses Go's init() functions for automatic registration:
```
func init() {
    registry.RegisterHandler("symlink", NewSymlinkHandler)
    registry.RegisterTrigger("filename", NewFileNameTrigger)
}
```

This approach ensures all components are available before main() runs.

File System Safety
------------------

dodot uses a layered approach to filesystem operations:

1. Pure Functions:
   • Handlers are pure functions (same input → same output).
   • No side effects during action generation.
   • Easy to test and reason about.

2. DataStore Interface:
   • All filesystem operations go through the DataStore abstraction.
   • Provides safe, tested implementations for all operations.
   • Handles path mapping, state management, and error recovery.

3. Self-Contained Actions:
   • Each action knows how to execute itself.
   • Actions are simple data structures that implement the Execute method.
   • This design enables dry-run, testing, and clear separation of concerns.

Benefits of This Architecture
-----------------------------

Separation of Concerns:
• Triggers focus only on file detection.
• Handlers focus only on generating high-level intents (`Actions`).
• The core engine handles planning (`Operations`).
• The executor handles the safety of writing to disk.

Extensibility:
• New triggers can be used with existing handlers.
• New handlers can work with existing triggers.
• The registry system enables a plugin-like architecture.

Testability:
• Each component can be tested in isolation.
• Pure functions enable predictable testing.
• No filesystem dependencies in the core logic.

Safety:
• No direct filesystem operations in application code.
• Validation occurs before any changes are made.
• The executor library provides safe, transactional-like behavior.

Predictability:
• Same inputs always produce the same outputs.
• Clear data flow through the pipeline.
• Easy to debug and understand.

Configuration Flow
------------------

Configuration is resolved in this order:
1. Default matchers (built into dodot).
2. Global configuration files.
3. Pack-specific `.dodot.toml` files.
4. Command-line overrides.

This allows fine-grained control while maintaining sensible defaults.

Pack Processing
---------------

Each pack is processed independently:
1. Load pack configuration (`.dodot.toml` if present).
2. Apply ignore rules from `.dodotignore` files.
3. Run the trigger/action/operation pipeline for all files in the pack.

Multiple packs can be processed in parallel since they are independent.

Action Execution
----------------

Actions are self-contained and execute directly through the DataStore interface:
• LinkAction → Creates symlinks via DataStore.CreateSymlink
• AddToPathAction → Manages PATH entries via DataStore.AddToPath
• AddToShellProfileAction → Sources scripts via DataStore.AddToShellProfile
• RunScriptAction → Executes scripts via DataStore.RunScript
• BrewAction → Runs Homebrew bundles via DataStore.RunBrew

Each action handles its own execution logic, including error handling,
idempotency checks, and state management.

Error Handling
--------------

Errors are handled at appropriate levels:
• Trigger errors - Skip individual files, continue processing.
• Handler errors - Fail the handler, continue with others.
• Execution errors - Stop processing and report the failure.

This provides graceful degradation while preventing partial linking.

Error Codes:
All errors use structured error codes (not just messages) for stable testing:
```
errors.New(errors.ErrFileAccess, "permission denied")
errors.New(errors.ErrActionInvalid, "missing target path")
```

Run-Once Mechanism
------------------

For handlers like provision scripts and `homebrew`, a sentinel file system prevents
repeated execution:
1. Before execution, check for sentinel file with matching checksum
2. If found and checksum matches, skip execution
3. After successful execution, write sentinel with current file checksum
4. If source file changes, checksum mismatch triggers re-execution

Sentinel files are stored in:
• ~/.local/share/dodot/provision/<pack>_<script>.sentinel
• ~/.local/share/dodot/homebrew/<pack>

Performance Considerations
--------------------------

• Parallel pack processing when using --all flag
• File operations batched through synthfs for efficiency
• Registry lookups are O(1) using Go maps
• Minimal file I/O during discovery phase
• Lazy loading of pack configurations