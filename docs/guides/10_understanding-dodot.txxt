                   Understanding dodot

This document explains dodot's core concepts, architecture, and execution
flow. It provides the mental model you need to use and extend dodot
effectively.

Reading Guide
-------------

Start here, then explore:
• 00_quick-start.txxt - Get running in 5 minutes
• 20_architecture.txxt - Technical implementation details  
• 30_design-philosophy.txxt - Why dodot works this way
• 40_extensibility.txxt - Adding new triggers and handlers
• 50_data-storage.txxt - Where dodot stores its data

The TLDR
--------

• Users centralize their dotfiles/configs under source control in a single repository.
• In this repository, users organize configurations by grouping related files into directories, called
  "packs." This forms the unit of work that can be deployed or installed together.
• dodot performs various tasks ("skills") like creating symlinks, modifying the shell profile, etc.
• dodot discovers what to do with each file primarily through naming conventions (e.g., a bin directory is
  added to $PATH, an aliases.sh file is sourced into the shell profile).

Ideas and Concepts
------------------

1. Dotfiles Root: The path to the user's centralized dotfiles repository that dodot will manage.

2. Pack: A directory of related dotfiles. The user decides the grouping criteria. A directory is considered
   a pack unless it contains a .dodotignore file.

3. Handler: A "skill" that dodot possesses. For example, the symlink handler can link config files, the
   path handler can add directories to the system $PATH, and the shell_profile handler can source scripts
   into the user's shell.

4. Trigger: A function that determines if a file should be processed. It takes a file path and returns true
   or false. For example, a FileNameTrigger could fire for any file named "Brewfile," or an ExtensionTrigger
   could fire for any file ending in .sh.

5. Matcher: A configuration layer that binds a Trigger to a Handler. For example, a matcher defines that
   the FileNameTrigger for "Brewfile" should activate the homebrew handler.

   > -- Intermezzo --
   > Users think in terms of Packs and Handlers, which maps to their mental model: "I group these files
   > together, and dodot should do this specific thing to them." The internal machinery of Triggers and
   > Matchers is an implementation detail that provides immense flexibility.
   >
   > Decoupling the "what" (Handler) from the "how it's found" (Trigger) simplifies development and
   > allows users to remap these relationships in their config files. If handler authors also had to manage
   > filename matching logic, it would lead to duplicated work, more bugs, and higher friction for
   > contributors.

6. Action: A high-level description of what a handler needs to happen on the user's system (e.g., "create a
   symlink from file X to location Y"). Handlers are pure functions; they don't run commands or touch the
   filesystem. They only return a list of Actions. This separation simplifies handler development and
   ensures that complex tasks like path resolution, dry runs, and safe execution are handled consistently by
   a central engine.

7. Operations & Execution: An Action is just an intent. To execute it, it must be translated into low-level,
   concrete tasks. We leverage the go-synthfs library for this.
   • `synthfs` Operation: A single, atomic filesystem task, like CreateDir or WriteFile.
   • `synthfs` Batch: A collection of synthfs operations. go-synthfs can execute a batch, automatically
     handling dependencies (e.g., creating a directory before the file inside it).

   The final step of dodot's planning phase is to convert each Action into one or more synthfs Operations,
   which are then added to a batch for execution. This means, outside of a few integration tests, the entire
   dodot program can be treated as a pure function that produces a synthfs batch as its final output.

The High-Level Execution Flow
------------------------------

This is the sequence of events when a dodot command runs:

1. Get Packs: dodot resolves the DotfilesRoot and determines which packs to operate on, respecting --all
   flags and .dodotignore files.

2. Get Firing Triggers: For each pack, dodot runs all configured Matchers against the filesystem, producing
   a list of TriggerMatch objects where files have been successfully matched to a Handler.

3. Get Actions: The TriggerMatch objects are grouped by Handler. Each Handler is then executed with its
   list of matched files, returning a list of high-level Actions.

4. Convert Actions to `synthfs` Batch: The collected list of all Actions is converted into a synthfs Batch
   containing low-level synthfs Operations.

5. Execute Batch: The synthfs library executes the batch, making the required changes to the filesystem.

6. Assemble Result: A structured result object is created from the outcome of the execution. The cmd/ layer
   is then responsible for formatting this result for display to the user.

In Short:

• Get packs to work on.
• Run matchers against the packs to find files and activate handlers.
• Run handlers to collect their resulting Actions.
• Transform Actions into a synthfs batch of operations.
• Execute the batch.
• Assemble and display the results.