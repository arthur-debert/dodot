Status Representation Guide
===========================

This guide explains how dodot represents and determines the status of packs and 
powerups throughout the system. This status representation is used across multiple 
commands (status, deploy, install) and provides a unified way to show what has 
been deployed and what will happen.


Overview
--------

The status system answers two fundamental questions:
1. What has already been deployed? (past/current state)
2. What will happen if I deploy? (future/predicted state)

This information is displayed using a consistent three-column format across all
commands, as specified in docs/dev/specs/pack-output.txxt.


Architecture
------------

The status determination follows this flow:

1. **Pack Discovery**
   - Uses the standard pack selection loop
   - Filters to requested packs (or all if none specified)

2. **Action Discovery**
   - Uses the standard matcher loop (GetFiringTriggers → GetActions)
   - This gives us all potential actions for each pack
   - Same actions that deploy/install would execute
   - Respects pack configuration (.dodot.toml) for overrides

3. **Status Checking**
   - For each action, determine its current deployment status
   - Check the dodot data directory for deployment artifacts
   - Identify broken deployments (e.g., deleted source files)

4. **Display Transformation**
   - Convert actions + statuses into DisplayResult
   - Group by pack, apply status aggregation rules
   - Format for terminal output


Status Determination
--------------------

### Past/Current State (What's Deployed)

Dodot tracks deployments using a persistent structure in the data directory
(typically ~/.local/share/dodot/):

    $DODOT_DATA_DIR/
    ├── deployed/
    │   ├── symlink/        # Intermediate symlinks
    │   ├── path/           # PATH directories
    │   └── shell_profile/  # Shell scripts to source
    ├── install/            # Install script sentinels
    └── homebrew/          # Homebrew sentinels

To determine if something is deployed:

1. **Symlinks**: Check if intermediate symlink exists in deployed/symlink/
   - Also verify the chain: target → intermediate → source
   - Detect broken links if source was deleted

2. **Shell Profiles**: Check if script exists in deployed/shell_profile/
   - These are sourced by dodot-init.sh

3. **PATH entries**: Check if directory symlink exists in deployed/path/
   - These are added to PATH by dodot-init.sh

4. **Install Scripts**: Check for sentinel file in install/
   - Sentinel contains checksum and timestamp
   - For run-once scripts, presence = executed

5. **Homebrew**: Check for Brewfile sentinel in homebrew/
   - Contains timestamp of last execution


### Future State (What Will Happen)

For undeployed items, we predict what will happen based on the Action data:

1. **Use the standard action discovery**
   - Same matching process as deploy/install
   - Ensures predictions match what will actually happen

2. **Generate prediction messages from Action properties**
   - ActionTypeLink: "will symlink to {action.Target}"
   - ActionTypeBrew: "will run homebrew install"
   - ActionTypeInstall: "will execute install script"
   - ActionTypePathAdd: "will add to PATH"
   - ActionTypeShellSource: "will be sourced in shell init"

3. **No execution needed**
   - Don't need dry-run mode or mock execution
   - Action struct contains all necessary information


Status States
-------------

Each file/action can have one of these states:

- **success**: Already deployed and working
- **pending**: Not yet deployed, will be created
- **error**: Deployment failed or is broken
- **ignored**: Explicitly ignored via .dodotignore
- **config**: Configuration file marker

Pack-level status is aggregated from file statuses (see pack-output.txxt).


Special Cases
-------------

### Pack Configuration Overrides

When a pack contains a .dodot.toml configuration file, it can override how files
are processed. The status system respects these overrides:

1. **File Mapping Overrides**
   ```toml
   [[files]]
   name = "foo"
   powerup = "homebrew"
   ```
   - Status will show: "homebrew : *foo : [status message]"
   - The asterisk (*) indicates an overridden filename
   - The powerup shown is the one from config, not the default matcher

2. **How It Works**
   - The matcher loop reads .dodot.toml during action discovery
   - Actions are generated with the overridden powerup type
   - Status display shows the actual powerup that will be/was used
   - File path shows the override marker (*)

3. **Example**
   If git/.dodot.toml maps "foo" to homebrew powerup:
   ```
   git:
       config    : .dodot.toml    : dodot config file found
       homebrew  : *foo           : will run homebrew install
   ```

This ensures status accurately reflects what will actually happen during deployment,
including all user customizations.

### Broken Deployments

A deployment can be "broken" when:
- Source file in dotfiles was deleted but symlink remains
- Install script was modified after execution
- Brewfile changed since last run

These are shown with special status messages:
- "linked to ~/.vimrc (broken - source file missing)"
- "executed on 2024-01-15 (source file changed)"

### Environment Variables

The dodot-init.sh script also populates environment variables:
- DODOT_SYMLINKS
- DODOT_SHELL_PROFILES  
- DODOT_PATH_DIRS
- etc.

These represent the "active" state in the current shell but are NOT used
for status checking because:
- Not available in fresh shells
- Could be stale or manually modified
- Shell-specific rather than system-wide

The data directory files are the authoritative source for deployment status.


Implementation Notes
--------------------

1. **Single Source of Truth**: The data directory structure IS the deployment
   state. If it's there, it was deployed by dodot.

2. **Performance**: Checking data directory is fast - just file existence checks
   rather than parsing system configuration files.

3. **Consistency**: All commands use the same status checking logic, ensuring
   consistent output whether running status, deploy, or install.

4. **Testability**: Status checking can be tested with mock filesystems since
   it only relies on file existence in known locations.