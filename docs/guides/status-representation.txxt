Status Representation Guide
===========================

This guide explains how dodot represents and determines the status of packs and 
handlers throughout the system. This status representation is used across multiple 
commands (status, link, provision) and provides a unified way to show what has 
been linked and what will happen.


Overview
--------

The status system answers two fundamental questions:
1. What has already been linked? (past/current state)
2. What will happen if I link? (future/predicted state)

This information is displayed using a consistent three-column format across all
commands, as specified in docs/dev/specs/pack-output.txxt.


Architecture
------------

The status determination follows this flow:

1. **Pack Discovery**
   - Uses the standard pack selection loop
   - Filters to requested packs (or all if none specified)

2. **Action Discovery**
   - Uses the standard matcher loop (GetFiringTriggers → GetActions)
   - This gives us all potential actions for each pack
   - Same actions that link/provision would execute
   - Respects pack configuration (.dodot.toml) for overrides

3. **Status Checking**
   - For each action, determine its current link status
   - Check the dodot data directory for link artifacts
   - Identify broken links (e.g., deleted source files)

4. **Display Transformation**
   - Convert actions + statuses into DisplayResult
   - Group by pack, apply status aggregation rules
   - Format for terminal output


Status Determination
--------------------

### Past/Current State (What's Deployed)

Dodot tracks links using a persistent structure in the data directory
(typically ~/.local/share/dodot/):

    $DODOT_DATA_DIR/
    ├── deployed/
    │   ├── symlink/        # Intermediate symlinks
    │   ├── path/           # PATH directories
    │   └── shell/  # Shell scripts to source
    ├── install/            # Install script sentinels
    └── homebrew/          # Homebrew sentinels

To determine if something is linked:

1. **Symlinks**: Check if intermediate symlink exists in deployed/symlink/
   - Also verify the chain: target → intermediate → source
   - Detect broken links if source was deleted

2. **Shell Profiles**: Check if script exists in deployed/shell/
   - These are sourced by dodot-init.sh

3. **PATH entries**: Check if directory symlink exists in deployed/path/
   - These are added to PATH by dodot-init.sh

4. **Install Scripts**: Check for sentinel file in install/
   - Sentinel contains checksum and timestamp
   - For run-once scripts, presence = executed

5. **Homebrew**: Check for Brewfile sentinel in homebrew/
   - Contains timestamp of last execution


### Future State (What Will Happen)

For unlinked items, we predict what will happen based on the Action data:

1. **Use the standard action discovery**
   - Same matching process as link/provision
   - Ensures predictions match what will actually happen

2. **Generate prediction messages from Action properties**
   - ActionTypeLink: "will symlink to {action.Target}"
   - ActionTypeBrew: "will run homebrew bundle"
   - ActionTypeInstall: "will execute provision script"
   - ActionTypePathAdd: "will add to PATH"
   - ActionTypeShellSource: "will be sourced in shell init"

3. **No execution needed**
   - Don't need dry-run mode or mock execution
   - Action struct contains all necessary information


Status States
-------------

Each file/action can have one of these states:

- **success**: Already linked and working
- **pending**: Not yet linked, will be created
- **error**: Deployment failed or is broken
- **ignored**: Explicitly ignored via .dodotignore
- **config**: Configuration file marker

Pack-level status is aggregated from file statuses (see pack-output.txxt).


Special Cases
-------------

### Pack Configuration Overrides

When a pack contains a .dodot.toml configuration file, it can override how files
are processed. The status system respects these overrides:

1. **File Mapping Overrides**
   ```toml
   [[files]]
   name = "foo"
   handler = "homebrew"
   ```
   - Status will show: "homebrew : *foo : [status message]"
   - The asterisk (*) indicates an overridden filename
   - The handler shown is the one from config, not the default matcher

2. **How It Works**
   - The matcher loop reads .dodot.toml during action discovery
   - Actions are generated with the overridden handler type
   - Status display shows the actual handler that will be/was used
   - File path shows the override marker (*)

3. **Example**
   If git/.dodot.toml maps "foo" to homebrew handler:
   ```
   git:
       config    : .dodot.toml    : dodot config file found
       homebrew  : *foo           : will run homebrew bundle
   ```

This ensures status accurately reflects what will actually happen during linking,
including all user customizations.

### Broken Deployments

A link can be "broken" when:
- Source file in dotfiles was deleted but symlink remains
- Install script was modified after execution
- Brewfile changed since last run

These are shown with special status messages:
- "linked to ~/.vimrc (broken - source file missing)"
- "executed on 2024-01-15 (source file changed)"

### Environment Variables

The dodot-init.sh script also populates environment variables:
- DODOT_SYMLINKS
- DODOT_SHELL_PROFILES  
- DODOT_PATH_DIRS
- etc.

These represent the "active" state in the current shell but are NOT used
for status checking because:
- Not available in fresh shells
- Could be stale or manually modified
- Shell-specific rather than system-wide

The data directory files are the authoritative source for link status.


Status Checking Design
----------------------

### Where Status Logic Lives

The status checking logic is implemented as methods on the Action struct. This 
design decision is based on the principle that **the code that knows how to 
create something should know how to verify it exists**.

### Action-Based Status Checking

Each Action knows:
- What it will create or modify
- Where it will create it  
- How to check if it was already done

This is implemented by adding a CheckStatus method to the Action struct:

```go
func (a *Action) CheckStatus(fs synthfs.FS, paths *Paths) (Status, error) {
    switch a.Type {
    case ActionTypeLink:
        return a.checkSymlinkStatus(fs, paths)
    case ActionTypeRun, ActionTypeInstall:
        return a.checkScriptStatus(fs, paths)
    case ActionTypePathAdd:
        return a.checkPathStatus(fs, paths)
    case ActionTypeShellSource:
        return a.checkShellSourceStatus(fs, paths)
    // ... other action types
    }
}
```

### Benefits of This Approach

1. **Cohesion**: The knowledge of how to create and verify stays together
2. **No Duplication**: Only the Action knows about intermediate symlinks,
   sentinel files, etc.
3. **Extensibility**: New action types automatically include their verification
   logic
4. **Testability**: Each action type's status checking can be tested 
   independently

### Example: Symlink Status Checking

For a symlink action, the status check would:
1. Check if intermediate symlink exists in `deployed/symlink/`
2. Verify the symlink chain is intact
3. Detect if source file was deleted (broken link)

```
Status States:
- SUCCESS: "linked to ~/.vimrc" 
- PENDING: "will symlink to ~/.vimrc"
- ERROR: "linked to ~/.vimrc (broken - source missing)"
```


Implementation Strategy
-----------------------

### Bottom-Up Development Approach

Build the status system incrementally, starting with the core building blocks:

1. **Phase 1: Core Action Status Checking**
   - Implement Action.CheckStatus for basic success/pending states
   - Focus on simple existence checks:
     * ActionTypeLink: Does the intermediate symlink exist?
     * ActionTypeInstall/ActionTypeBrew: Does the sentinel file exist?
     * ActionTypePathAdd: Does the path symlink exist in the data directory?
     * ActionTypeShellSource: Is the source file linked in deployed/shell/?
   - This delivers core value quickly with minimal complexity

2. **Phase 2: Pack-Level Status**
   - Aggregate action statuses for a single pack
   - Apply pack status rules (error → alert, etc.)
   - Handle special files (.dodot.toml, .dodotignore)

3. **Phase 3: Multi-Pack Status**
   - Iterate over multiple/all packs
   - Format for display output

4. **Phase 4: Enhanced Status Detection**
   - Add "broken" state detection in stages:
     * Stage 1: Detect broken symlinks (source file deleted)
     * Stage 2: Checksum verification for modified scripts (can defer)
   - These can be added without changing the core architecture

### Implementation Guidelines

1. **Keep It Simple**: 
   - No caching layer initially
   - No complex performance optimizations
   - Address performance only if users report issues

2. **Data Directory Documentation**:
   - Document that $DODOT_DATA_DIR contains important state
   - Warn users not to delete it carelessly
   - Explain it's the authoritative source for link status


Implementation Notes
--------------------

1. **Single Source of Truth**: The data directory structure IS the link
   state. If it's there, it was linked by dodot.

2. **Performance**: Checking data directory is fast - just file existence checks
   rather than parsing system configuration files.

3. **Consistency**: All commands use the same status checking logic, ensuring
   consistent output whether running status, link, or provision.

4. **Testability**: Status checking can be tested with mock filesystems since
   it only relies on file existence in known locations.

5. **Action-Centric**: Actions are responsible for both execution and 
   verification, keeping related logic together.

6. **Incremental Delivery**: Start with core status checking, add advanced 
   features iteratively based on user needs.