                   Design Philosophy

This document explains the core principles and trade-offs behind dodot's
design. Understanding these principles helps explain why dodot works the
way it does and whether it fits your use case.

For technical concepts and implementation details, see 10_understanding-dodot.txxt
and 20_architecture.txxt.

Core Principles
---------------

1. Versioning is left to git
2. No installs, only linking - changes are always live
3. No state management - linking is idempotent
4. Complete freedom for users on file structure  
5. Dead simple operation

The Big Picture
---------------

These principles are deeply interconnected. By leaving versioning to git,
we ensure your dotfiles repository IS your linked configuration. Combined with live
changes, this means files under source control are the actual linked
files - not copies.

This is achieved primarily through symbolic links. For many handlers
(`symlink`, `shell`), the file in your repository acts as the link
source. There's nothing to "update" since changes to these config files
are immediately live on the system.

This is managed through dodot's intermediate link layer—creating a 
double-link structure that provides both live editing and robust state
management through the filesystem itself.

File Organization Philosophy
----------------------------

Directories as Packs:
You organize related configurations under directories called "packs". The
grouping criteria is entirely up to you:

• By software (neovim pack for vim configurations)
• By workflow (python-dev pack for development tools)
• By machine type (macos-laptop for macOS-specific configs)

File Naming Conventions:
dodot works primarily through file naming conventions:
• "bin" directory → added to system PATH
• "aliases.sh" file → sourced into shell profile
• "vimrc" file → symlinked to ~/.vimrc
• "Brewfile" → processed by Homebrew

Override any convention using a `.dodot.toml` configuration file.

Trade-offs and Consequences
---------------------------

Benefits:
• Simple mental model - your git repo is your linked configuration.
• Live editing for symlinked files - changes are immediately active.
• No complex state management or databases.
• Easy backup and portability (just git).
• Works with any existing git repository structure.

Limitations:
• Some handlers (`provision`, `homebrew`) require a `dodot link` run to apply changes.
• No built-in versioning beyond git.
• Structural changes (adding new files) require relinking.
• provision scripts must be idempotent.

Examples of Trade-offs:

Immediate vs. Deployed Changes:
• **Live:** Edit a file handled by the `symlink` or `shell`
  handlers. The changes are live instantly (or on the next shell start).
• **Requires Linking:** Edit a provision script or a `Brewfile`.
  You must run `dodot link` for the changes to take effect.

Structural Changes:
If you link a pack without an `aliases.sh` file, then later add one, it
won't be active until you run `dodot link` again, as the necessary
symlink wasn't created initially. Use the `dodot fill` command to create
placeholder files if needed.

Run-Once Operations:
Actions like provision scripts and `Brewfile` processing are tracked
via sentinel files to prevent them from running on every single link operation.
They only re-run if the source file changes.


The Stateless Advantage
-----------------------

No State Management:
• No tracking database or metadata files
• Each link operation is independent and complete
• No complex upgrade/downgrade procedures
• Easy to reason about and debug

Idempotent Operations:
Running the same link command multiple times produces the same result. This
makes dodot predictable and safe for automation.

File System Safety:
dodot never directly manipulates files. Instead, it generates descriptions
of operations that are executed by a specialized file system library
(synthfs). This provides:
• Safer operations with validation
• Basic rollback capabilities  
• Easier testing through pure functions

When dodot Fits
---------------

dodot works well when you:
• Want simple, transparent dotfile management
• Are comfortable with git-based versioning
• Prefer live configuration editing
• Don't need complex link workflows
• Value simplicity over advanced features

dodot may not fit if you:
• Need controlled linking with approvals
• Require complex rollback scenarios
• Want built-in configuration versioning
• Need to manage secrets or sensitive data
• Require cross-platform compatibility guarantees

Design Philosophy Summary
-------------------------

dodot embraces simplicity over features. By accepting the constraints of
git-based versioning, symlink-based linking, and filesystem-as-database
design, it achieves a remarkably simple and predictable system.

The design makes certain advanced features impossible while making common
operations trivial. This is an intentional trade-off - dodot chooses to
do a few things extremely well rather than attempting to handle every
possible use case.