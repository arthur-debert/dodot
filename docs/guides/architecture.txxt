                   dodot Architecture

This document explains dodot's high-level architecture and how the core
components work together to process your dotfiles.

Core Components
---------------

dodot's architecture is built around four main concepts that work in
sequence:

1. Triggers - Pattern-matching engines that find relevant files
2. Matchers - Configuration that binds triggers to power-ups  
3. Power-ups - Action generators that process matched files
4. Actions - High-level descriptions of operations to perform

Processing Pipeline
-------------------

When you run a dodot command, this is what happens:

1. Discovery Phase:
   • Scan all packs to find files and directories.
   • Load pack configurations from `.dodot.toml` files.

2. Trigger Matching Phase:
   • Test each file against configured triggers (e.g., `filename`, `extension`).
   • Create `TriggerMatch` objects for files that match, linking them to a power-up.

3. Action Generation Phase:
   • Each power-up (e.g., `symlink`, `shell_profile`) processes its `TriggerMatch` objects.
   • The power-up generates high-level `Actions` that describe an intent, such as "link this file" or "source this script".

4. Operation Planning Phase:
   • `Actions` are converted into low-level, concrete `Operations`. An `Operation` is a specific task, like `CreateSymlink` or `WriteFile`.
   • This plan is created without yet touching the filesystem, enabling dry runs.

5. Execution Phase:
   • A specialized executor (powered by the `go-synthfs` library) safely executes the planned `Operations`.
   • It handles creating directories, writing files, and setting up symlinks in the correct order.

Component Details
-----------------

Triggers:
Triggers implement specific matching strategies:
• FileNameTrigger - Matches files by name patterns (e.g., `*rc`).
• DirectoryTrigger - Matches directories by name.
• ExtensionTrigger - Matches files by extension (e.g., `.sh`).

Each trigger simply identifies a file; it doesn't decide what to do with it.

Matchers:
Matchers are the glue in your configuration. They bind triggers to power-ups:
• Which trigger to use for detection.
• Which power-up should handle the matched files.
• Custom options for the power-up (e.g., the target directory for a symlink).

Matchers are configured globally and can be overridden per-pack.

Power-ups:
Power-ups are the brains of `dodot`. They generate `Actions` from matched files:
• `symlink` - Creates symbolic links to target locations.
• `shell_profile` - Ensures shell scripts are sourced by your shell.
• `shell_add_path` - Adds directories to your system's `$PATH`.
• `homebrew` - Processes `Brewfile` dependencies.
• `install` - Executes one-time installation scripts.

Power-ups never perform filesystem operations directly. They only describe
what should be done through `Actions`.

Actions vs. Operations:
`dodot` makes a key distinction between Actions and Operations:
• **Action**: A high-level intent (e.g., "link `vimrc`").
• **Operation**: A low-level, concrete task (e.g., "create a symlink from `/path/to/vimrc` to `~/.vimrc`").

This separation allows for clear planning and safe execution.

Registry System
---------------

All components (triggers and power-ups) are registered in a type-safe
registry system. This enables extensibility—new triggers and power-ups can
be added without modifying the core `dodot` code.

File System Safety
------------------

dodot uses a layered approach to filesystem operations:

1. Pure Functions:
   • Power-ups are pure functions (same input → same output).
   • No side effects during action generation.
   • Easy to test and reason about.

2. Synthetic Filesystem:
   • All operations go through the `go-synthfs` library.
   • Operations are validated before execution.
   • The library automatically handles dependencies (e.g., creating a directory before placing a file in it).

3. Operation Descriptions:
   • The core pipeline produces a list of `Operations`.
   • This list is just data, which enables powerful features like dry-run validation.

Benefits of This Architecture
-----------------------------

Separation of Concerns:
• Triggers focus only on file detection.
• Power-ups focus only on generating high-level intents (`Actions`).
• The core engine handles planning (`Operations`).
• The executor handles the safety of writing to disk.

Extensibility:
• New triggers can be used with existing power-ups.
• New power-ups can work with existing triggers.
• The registry system enables a plugin-like architecture.

Testability:
• Each component can be tested in isolation.
• Pure functions enable predictable testing.
• No filesystem dependencies in the core logic.

Safety:
• No direct filesystem operations in application code.
• Validation occurs before any changes are made.
• The executor library provides safe, transactional-like behavior.

Predictability:
• Same inputs always produce the same outputs.
• Clear data flow through the pipeline.
• Easy to debug and understand.

Configuration Flow
------------------

Configuration is resolved in this order:
1. Default matchers (built into dodot).
2. Global configuration files.
3. Pack-specific `.dodot.toml` files.
4. Command-line overrides.

This allows fine-grained control while maintaining sensible defaults.

Pack Processing
---------------

Each pack is processed independently:
1. Load pack configuration (`.dodot.toml` if present).
2. Apply ignore rules from `.dodotignore` files.
3. Run the trigger/action/operation pipeline for all files in the pack.

Multiple packs can be processed in parallel since they are independent.

Error Handling
--------------

Errors are handled at appropriate levels:
• Trigger errors - Skip individual files, continue processing.
• Power-up errors - Fail the power-up, continue with others.
• Execution errors - Stop processing and report the failure.

This provides graceful degradation while preventing partial deployments.