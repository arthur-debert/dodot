                   Data Storage and Organization

This guide explains dodot's approach to state management, how it stores
link information, and the rationale behind its design decisions.

The Double-Link Architecture
----------------------------

dodot could simply create direct symlinks from linked paths (e.g., ~/.zshrc)
to source files (e.g., $DOTFILES_ROOT/shell/zshrc). Instead, it uses a 
double-link structure where the linked file points to an intermediate 
symlink in dodot's state directory, which then points to the source file.

Why this design? The answer is state management. This structure ties together
the link result, the thing itself, and our state representation.

Alternative approaches like direct links with a JSON state file would require
keeping the link and state in sync. Our design has key advantages:

• No risk of being out of sync - the link IS the state
• Easy debugging - if a state symlink points to a missing source file,
  it's immediately visible
• Robust and simple - no parsing, no corruption, just filesystem operations

In essence: the filesystem structure itself is the state database.

State Storage Structure
-----------------------

Here's what dodot's state storage looks like after linking various handlers:

```
~/.local/share/dodot/
├── deployed/
│   ├── symlink/         # Intermediate symlinks for regular files
│   │   ├── .vimrc → ~/dotfiles/vim/vimrc
│   │   ├── .zshrc → ~/dotfiles/zsh/zshrc
│   │   └── .gitconfig → ~/dotfiles/git/gitconfig
│   │
│   ├── shell/   # Shell scripts to source
│   │   ├── vim_aliases.sh → ~/dotfiles/vim/aliases.sh
│   │   ├── git_functions.sh → ~/dotfiles/git/functions.sh
│   │   └── tools_env.sh → ~/dotfiles/tools/env.sh
│   │
│   └── path/           # Directories to add to PATH
│       ├── tools-bin → ~/dotfiles/tools/bin
│       └── scripts-local → ~/dotfiles/scripts/.local/bin
│
├── homebrew/           # Brew execution tracking
│   ├── tools_Brewfile.sentinel    # "sha256:2024-01-15T10:00:00Z"
│   └── dev_Brewfile.sentinel      # "sha256:2024-01-20T14:30:00Z"
│
├── install/            # Provision script tracking
│   ├── vim_install.sh.sentinel    # "sha256:2024-01-10T09:00:00Z"
│   ├── tools_setup.sh.sentinel    # "sha256:2024-01-12T11:00:00Z"
│   └── tools/                     # Copied scripts
│       └── setup.sh
│
└── shell/
    └── dodot-init.sh   # Sources everything in shell/ and adds path/ to PATH
```

How Each Handler Stores State
------------------------------

1. Symlink Handler:
   • Creates intermediate symlink in deployed/symlink/
   • User's file (e.g., ~/.vimrc) points to intermediate
   • Intermediate points to source in pack
   • State = existence of these symlinks

2. Shell Profile Handler:
   • Creates symlinks in deployed/shell/
   • Naming: <pack>_<filename> (e.g., vim_aliases.sh)
   • dodot-init.sh sources all files in this directory
   • State = existence of symlinks

3. Path Handler:
   • Creates symlinks in deployed/path/
   • Naming: <pack>-<dirname> (e.g., tools-bin)
   • Each symlink points to a directory to add to PATH
   • dodot-init.sh iterates through these and adds to PATH
   • State = existence of directory symlinks

4. Homebrew Handler:
   • Creates sentinel files in homebrew/
   • Format: <pack>_Brewfile.sentinel
   • Content: "checksum:timestamp"
   • State = sentinel existence and checksum match

5. Install Script Handler:
   • Creates sentinel files in install/
   • Copies scripts before execution for safety
   • Format: <pack>_<script>.sentinel
   • Content: "checksum:timestamp"
   • State = sentinel existence and checksum match

File Deployment Mapping
-----------------------

The relationship between source files and linked locations follows
intelligent mapping rules:

Default Mapping:
• Pack root files → home with dot prefix (vimrc → ~/.vimrc)
• Pack subdirectories → XDG directories or home subdirectories
• Special handling for known directories (ssh, vim, etc.)

Mapping can be customized via:
• Pack configuration in .dodot.toml
• Explicit _home/ or _xdg/ prefixes in paths
• Handler options like target_dir

The Pack Concept
----------------

dodot organizes configurations into "packs" - directories containing
related files that get linked together. This provides logical grouping
and makes it easy to enable/disable related configurations.

Example pack structure:
```
DOTFILES_ROOT/
├── vim/                    # vim pack
│   ├── vimrc              # → ~/.vimrc
│   ├── gvimrc             # → ~/.gvimrc  
│   └── .dodot.toml        # pack configuration
├── git/                   # git pack
│   ├── gitconfig          # → ~/.gitconfig
│   ├── gitignore_global   # → ~/.gitignore_global
│   └── aliases.sh         # sourced in shell profile
└── development/           # development pack
    ├── bin/               # added to PATH
    │   └── dev-scripts
    ├── Brewfile           # processed by Homebrew
    └── install.sh         # executed once
```

Shell Integration
-----------------

dodot uses a single shell integration point: dodot-init.sh. This script:

1. Sources all files in deployed/shell/
2. Adds all directories in deployed/path/ to PATH
3. Exports environment variables for tracking
4. Provides helper functions for status checking

Your shell profile (.zshrc, .bashrc) only needs one line to source
dodot-init.sh, avoiding multiple integration points.

Storage Benefits
----------------

Version Control Integration:
• Everything is stored in your git repository
• No external databases or metadata
• Easy to backup, share, and version

Transparency:
• You can see exactly what will be linked
• The state IS the link - no hidden metadata
• Easy to debug by examining symlinks

Portability:
• Works on any system with git and dodot
• No migration or export procedures needed
• Self-contained in your dotfiles repository

Live Editing:
• Edit files directly in your repository
• Changes are immediately active via symlinks
• No separate update or sync commands needed

Storage Limitations
-------------------

Structural Changes:
If you add new files to a pack after linking, they won't be active
until relinking. Use 'dodot fill' to create placeholder files that
get linked immediately.

Binary Files:
dodot works best with text configuration files. Binary files can be
stored but don't benefit from live editing.

Secrets Management:
dodot doesn't provide built-in secrets management. Use external tools
like pass, 1Password CLI, or environment variables for sensitive data.

Platform Differences:
Some files may be platform-specific. Use separate packs or conditional
logic in install.sh scripts to handle differences.

Data Recovery
-------------

Since everything is in git:
1. Your configurations are versioned and backed up
2. You can restore to any previous state via git
3. No special recovery procedures needed
4. Symlinks will continue working even without dodot

To completely remove dodot traces:
1. Remove symlinks: replace with actual files if desired
2. Remove shell integration line from profiles
3. Clean up DODOT_DATA_DIR if desired
4. Your dotfiles repository remains intact and usable

Understanding State Through Examples
------------------------------------

To check what's linked:
```
# See all intermediate symlinks
ls -la ~/.local/share/dodot/deployed/symlink/

# See what's added to PATH
ls -la ~/.local/share/dodot/deployed/path/

# Check if a Brewfile was processed
ls ~/.local/share/dodot/homebrew/
```

To understand a link:
```
# Follow the symlink chain for .vimrc
readlink ~/.vimrc
# → /Users/you/.local/share/dodot/deployed/symlink/.vimrc

readlink /Users/you/.local/share/dodot/deployed/symlink/.vimrc  
# → /Users/you/dotfiles/vim/vimrc
```

The beauty is that the link structure tells you everything:
• What's linked (symlinks exist)
• Where it came from (follow the symlinks)
• What's broken (dangling symlinks)
• What changed (checksum mismatches in sentinels)

No database queries, no state files to parse - just ls and readlink.