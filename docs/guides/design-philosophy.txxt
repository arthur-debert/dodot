                   Design Philosophy

This document explains the core principles and trade-offs behind dodot's
design. Understanding these principles helps explain why dodot works the
way it does and whether it fits your use case.

Core Principles
---------------

1. Versioning is left to git
2. No installs, only deployments - changes are always live
3. No state management - deployments are idempotent
4. Complete freedom for users on file structure  
5. Dead simple operation

The Big Picture
---------------

These principles are deeply interconnected. By leaving versioning to git,
we ensure your dotfiles repository IS your deployment. Combined with live
changes, this means files under source control are the actual deployed
files - not copies.

This is achieved primarily through symbolic links. For many power-ups
(`symlink`, `shell_profile`), the file in your repository acts as the link
source. There's nothing to "update" since changes to these config files
are immediately live on the system.

This enables stateless deployments—just linking paths from your system
to your source-controlled repository.

File Organization Philosophy
----------------------------

Directories as Packs:
You organize related configurations under directories called "packs". The
grouping criteria is entirely up to you:

• By software (neovim pack for vim configurations)
• By workflow (python-dev pack for development tools)
• By machine type (macos-laptop for macOS-specific configs)

File Naming Conventions:
dodot works primarily through file naming conventions:
• "bin" directory → added to system PATH
• "aliases.sh" file → sourced into shell profile
• "vimrc" file → symlinked to ~/.vimrc
• "Brewfile" → processed by Homebrew

Override any convention using a `.dodot.toml` configuration file.

Trade-offs and Consequences
---------------------------

Benefits:
• Simple mental model - your git repo is your deployment.
• Live editing for symlinked files - changes are immediately active.
• No complex state management or databases.
• Easy backup and portability (just git).
• Works with any existing git repository structure.

Limitations:
• Some power-ups (`install`, `homebrew`) require a `dodot deploy` run to apply changes.
• No built-in versioning beyond git.
• Structural changes (adding new files) require redeployment.
• `install` scripts must be idempotent.

Examples of Trade-offs:

Immediate vs. Deployed Changes:
• **Live:** Edit a file handled by the `symlink` or `shell_profile`
  power-ups. The changes are live instantly (or on the next shell start).
• **Requires Deployment:** Edit an `install.sh` script or a `Brewfile`.
  You must run `dodot deploy` for the changes to take effect.

Structural Changes:
If you deploy a pack without an `aliases.sh` file, then later add one, it
won't be active until you run `dodot deploy` again, as the necessary
symlink wasn't created initially. Use the `dodot fill` command to create
placeholder files if needed.

Run-Once Operations:
Actions like `install.sh` scripts and `Brewfile` processing are tracked
via sentinel files to prevent them from running on every single deployment.
They only re-run if the source file changes.


The Stateless Advantage
-----------------------

No State Management:
• No tracking database or metadata files
• Each deployment is independent and complete
• No complex upgrade/downgrade procedures
• Easy to reason about and debug

Idempotent Operations:
Running the same deployment multiple times produces the same result. This
makes dodot predictable and safe for automation.

File System Safety:
dodot never directly manipulates files. Instead, it generates descriptions
of operations that are executed by a specialized file system library
(synthfs). This provides:
• Safer operations with validation
• Basic rollback capabilities  
• Easier testing through pure functions

When dodot Fits
---------------

dodot works well when you:
• Want simple, transparent dotfile management
• Are comfortable with git-based versioning
• Prefer live configuration editing
• Don't need complex deployment workflows
• Value simplicity over advanced features

dodot may not fit if you:
• Need controlled deployment with approvals
• Require complex rollback scenarios
• Want built-in configuration versioning
• Need to manage secrets or sensitive data
• Require cross-platform compatibility guarantees

Design Philosophy Summary
-------------------------

dodot embraces simplicity over features. By accepting the constraints of
git-based versioning, symlink deployment, and stateless operation, it
achieves a remarkably simple and predictable system.

The design makes certain advanced features impossible while making common
operations trivial. This is an intentional trade-off - dodot chooses to
do a few things extremely well rather than attempting to handle every
possible use case.