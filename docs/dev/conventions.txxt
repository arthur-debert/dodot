                   Code Conventions

This document defines coding standards, naming conventions, and best
practices for the dodot codebase.

General Go Conventions
----------------------

Follow standard Go conventions:
• Use gofmt for formatting
• Follow effective Go guidelines
• Use golangci-lint for static analysis
• Package names: short, lowercase, no underscores
• Interface names: noun or noun + "er" suffix

Naming Conventions
------------------

Types:
• PascalCase for exported types: TriggerMatch, PowerUp
• camelCase for unexported types: triggerRegistry
• Suffix interfaces with behavior: Matcher, Processor, Registry

Functions:
• PascalCase for exported: GetPacks, ProcessTriggers
• camelCase for unexported: buildMatcher, validatePath
• Getter functions don't use "Get" prefix unless for symmetry

Variables:
• camelCase for all variables
• Short names for short scopes: i, err, ok
• Descriptive names for longer scopes: triggerMatches, packConfig

Constants:
• PascalCase for exported: DefaultTimeout, MaxRetries
• camelCase for unexported: defaultConfigPath, maxPackSize
• Group related constants in blocks

Error Handling Conventions
---------------------------

Error Types:
```go
// Define error codes as typed constants
type ErrorCode string

const (
    PackNotFound     ErrorCode = "PACK_NOT_FOUND"
    InvalidConfig    ErrorCode = "INVALID_CONFIG"
    TriggerFailed    ErrorCode = "TRIGGER_FAILED"
)

// Use structured errors
type DodotError struct {
    Code    ErrorCode
    Message string
    Details map[string]interface{}
}
```

Error Creation:
```go
// Factory functions for common errors
func NewPackNotFoundError(packName string) *DodotError {
    return &DodotError{
        Code:    PackNotFound,
        Message: fmt.Sprintf("pack not found: %s", packName),
        Details: map[string]interface{}{
            "pack_name": packName,
        },
    }
}
```

Error Testing:
```go
// Test error codes, never messages
err := ProcessPack("nonexistent")
require.Error(t, err)
assert.Equal(t, errors.PackNotFound, err.Code)
```

Logging Conventions
-------------------

Logger Setup:
```go
// Get logger with context
logger := logging.GetLogger().With().
    Str("component", "triggers").
    Str("pack", pack.Name).
    Logger()
```

Log Levels:
• TRACE (-vvv): Very detailed execution flow
• DEBUG (-vv): Detailed debugging information
• INFO (-v): General information about operations
• WARN (default): Warnings and recoverable errors
• ERROR: Errors that prevent operation completion

Log Messages:
```go
// Good: Structured with context
logger.Debug().
    Str("trigger", trigger.Name()).
    Int("matches", len(matches)).
    Dur("duration", elapsed).
    Msg("trigger processing completed")

// Bad: Sprintf with no structure
logger.Debug().Msg(fmt.Sprintf("processed %d matches", len(matches)))
```

Function Design Conventions
----------------------------

Function Signatures:
```go
// Return error as last parameter
func ProcessPack(pack Pack) ([]Action, error)

// Use options pattern for complex configuration
func ProcessPackWithOptions(pack Pack, opts ...ProcessOption) ([]Action, error)

// Context as first parameter when needed
func ProcessPackWithContext(ctx context.Context, pack Pack) ([]Action, error)
```

Options Pattern:
```go
type ProcessOption func(*ProcessConfig)

func WithVerbose(verbose bool) ProcessOption {
    return func(c *ProcessConfig) {
        c.Verbose = verbose
    }
}

func WithDryRun(dryRun bool) ProcessOption {
    return func(c *ProcessConfig) {
        c.DryRun = dryRun
    }
}
```

Interface Design Conventions
-----------------------------

Small Interfaces:
```go
// Good: Single responsibility
type Trigger interface {
    Match(file FileInfo, pack Pack) (bool, error)
}

// Bad: Too many responsibilities
type TriggerProcessor interface {
    Match(file FileInfo, pack Pack) (bool, error)
    Process(matches []TriggerMatch) ([]Action, error)
    Validate(config Config) error
    GetMetadata() map[string]interface{}
}
```

Interface Composition:
```go
// Compose larger interfaces from smaller ones
type Processor interface {
    Trigger
    ActionGenerator
}

type ActionGenerator interface {
    GenerateActions(matches []TriggerMatch) ([]Action, error)
}
```

Testing Conventions
-------------------

Test Organization:
```go
func TestTriggerMatch(t *testing.T) {
    tests := []struct {
        name     string
        file     FileInfo
        pack     Pack
        expected bool
        wantErr  bool
    }{
        {
            name: "matches vimrc file",
            file: FileInfo{Name: "vimrc", IsDir: false},
            pack: Pack{Name: "vim"},
            expected: true,
            wantErr: false,
        },
        // ... more test cases
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            trigger := NewFileNameTrigger()
            result, err := trigger.Match(tt.file, tt.pack)
            
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.Equal(t, tt.expected, result)
            }
        })
    }
}
```

Test Helpers Usage:
```go
func TestPackProcessing(t *testing.T) {
    // Use testutil helpers
    pack := testutil.CreateTestPack(t, "vim", map[string]string{
        "vimrc": "set number",
        "gvimrc": "set columns=80",
    })
    
    registry := testutil.NewTestRegistry()
    registry.RegisterTrigger("filename", &FileNameTrigger{})
    
    logs := testutil.CaptureLogOutput(t, func() {
        actions, err := ProcessPack(pack)
        assert.NoError(t, err)
        assert.Len(t, actions, 2)
    })
    
    testutil.AssertLogContains(t, logs, "processing pack")
}
```

Documentation Conventions
--------------------------

Package Documentation:
```go
// Package triggers provides file and directory matching functionality
// for the dodot dotfiles manager.
//
// Triggers implement pattern-matching strategies to identify files that
// should be processed by specific power-ups. Each trigger focuses on a
// single matching criterion like file names, extensions, or directory
// patterns.
package triggers
```

Function Documentation:
```go
// ProcessTriggerMatches groups trigger matches by power-up and processes
// them to generate actions. It ensures that all files matched by the same
// power-up are processed together, enabling power-ups to handle related
// files as a unit.
//
// The function returns a slice of actions describing the operations to be
// performed, or an error if processing fails.
func ProcessTriggerMatches(matches []TriggerMatch) ([]Action, error) {
    // implementation
}
```

Type Documentation:
```go
// TriggerMatch represents a file that has been matched by a trigger and
// should be processed by a specific power-up. It contains all the context
// needed for the power-up to generate appropriate actions.
type TriggerMatch struct {
    File     FileInfo                   // The matched file
    Pack     Pack                       // The pack containing the file
    Trigger  string                     // Name of trigger that matched
    PowerUp  string                     // Name of power-up to process
    Options  map[string]interface{}     // Power-up configuration options
    Metadata map[string]interface{}     // Additional context from trigger
}
```

Code Organization Conventions
------------------------------

File Organization:
• One main type per file
• Related types can share files if small
• Tests in same package (*_test.go)
• Internal types in internal/ subdirectories

Import Organization:
```go
import (
    // Standard library
    "context"
    "fmt"
    "os"
    
    // Third-party packages
    "github.com/rs/zerolog"
    "github.com/spf13/cobra"
    
    // Local packages
    "github.com/dodot/pkg/core"
    "github.com/dodot/pkg/types"
)
```

Package Dependencies:
• Avoid circular dependencies
• Keep dependencies minimal
• Use internal/ for implementation details
• External dependencies in vendor/ or go.mod

Performance Conventions
-----------------------

Avoid Allocations:
```go
// Good: Reuse slices
actions := make([]Action, 0, len(matches))
for _, match := range matches {
    actions = append(actions, processMatch(match))
}

// Bad: Repeated allocation
var actions []Action
for _, match := range matches {
    newActions := processMatch(match)
    actions = append(actions, newActions...)
}
```

Use Sync.Pool for Expensive Objects:
```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 0, 1024)
    },
}

func processFile(file FileInfo) error {
    buffer := bufferPool.Get().([]byte)
    defer bufferPool.Put(buffer[:0])
    
    // use buffer
}
```

Context Usage:
```go
// Pass context through call chains
func ProcessPacks(ctx context.Context, packs []Pack) error {
    for _, pack := range packs {
        if err := ctx.Err(); err != nil {
            return err
        }
        
        if err := processPack(ctx, pack); err != nil {
            return err
        }
    }
    return nil
}
```

These conventions ensure consistency and maintainability across the
codebase while following Go best practices.