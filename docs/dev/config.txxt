 Configuration System Walkthrough

  1. Entry Point: Configuration Access

⏺ Read(pkg/config/access.go)
  ⎿  Read 20 lines (ctrl+r to expand)

⏺ pkg/config/access.go - The entry point:
  - When the app starts, Initialize() is called
  - It calls LoadConfiguration() from our new loader
  - Falls back to hardcoded Default() if loading fails
  - Provides global access functions like Get(), GetSecurity(), etc.

  2. Configuration Structures

⏺ Read(pkg/config/central.go)
  ⎿  Read 50 lines (ctrl+r to expand)

⏺ pkg/config/central.go - Configuration structures:
  - All structs now have koanf: tags with snake_case names
  - These tags map user-friendly YAML fields to Go struct fields
  - Example: ProtectedPaths map[string]bool koanf:"protected_paths"``
  - The structs define the shape of the entire configuration

  3. The Configuration Loader

⏺ Read(pkg/config/loader.go)
  ⎿  Read 80 lines (ctrl+r to expand)

⏺ pkg/config/loader.go - The heart of the system:

  1. Embedded files (lines 18-22):
    - Uses Go's //go:embed to include YAML files in the binary
    - defaultConfigYAML - System/internal defaults
    - userDefaultsYAML - User-friendly defaults
  2. Loading order (lines 63-95):
  System defaults → User defaults → User files → Environment vars
  (lowest priority)                              (highest priority)
  3. User config paths checked in order:
    - $DOTFILES_ROOT/.dodot/config.yaml (repo-specific)
    - $XDG_CONFIG_HOME/dodot/config.yaml
    - ~/.config/dodot/config.yaml (fallback)

  4. Embedded Configuration Files

⏺ Read(pkg/config/embedded/user-defaults.yaml)
  ⎿  Read 48 lines (ctrl+r to expand)

⏺ embedded/user-defaults.yaml - User-friendly defaults:
  - Clean snake_case naming (force_home, protected_paths)
  - What users would write in their own config files
  - Gets transformed to internal structure

⏺ Read(pkg/config/embedded/defaults.yaml)
  ⎿  Read 50 lines (ctrl+r to expand)

⏺ embedded/defaults.yaml - System defaults:
  - Internal configuration (logging, priorities, etc.)
  - Uses snake_case to match koanf struct tags
  - Includes matchers, security settings, etc.

  5. Configuration Transformation

⏺ Read(pkg/config/loader.go)
  ⎿  Read 50 lines (ctrl+r to expand)

⏺ Configuration transformation - This function maps user-friendly structure to internal:
  - pack.ignore → patterns.pack_ignore
  - symlink.protected_paths → security.protected_paths
  - symlink.force_home → link_paths.force_home
  - Converts arrays to maps where needed (e.g., ["ssh", "aws"] → {"ssh": true, "aws": true})

  6. How It All Works Together

  graph TD
      A[App Starts] --> B[config.Initialize called]
      B --> C[LoadConfiguration]
      C --> D[Load embedded defaults.yaml]
      D --> E[Load embedded user-defaults.yaml]
      E --> F[Transform user format to internal]
      F --> G[Check for user config files]
      G --> H{User config exists?}
      H -->|Yes| I[Load & merge user YAML]
      H -->|No| J[Skip to env vars]
      I --> J[Load env vars DODOT_*]
      J --> K[Unmarshal to Config struct]
      K --> L[Post-process config]
      L --> M[Return Config]

  7. Example: User Creates Custom Config

  User creates ~/.config/dodot/config.yaml:
  pack:
    ignore:
      - .myapp_cache
      - "*.log"

  symlink:
    force_home:
      - myapp  # Add custom app to force_home list

  What happens:
  1. System loads internal defaults (all the matchers, logging, etc.)
  2. Loads user defaults (standard ignores, force_home list)
  3. Loads user's config file
  4. Merges: user's pack.ignore adds to defaults, force_home adds "myapp"
  5. Environment vars can override: DODOT_PACK_IGNORE=.cache

  8. Environment Variable Support

  # Override configuration via environment
  export DODOT_PACK_IGNORE=".git,.svn"
  export DODOT_LOGGING_DEFAULT_LEVEL="debug"
  export DODOT_SYMLINK_FORCE_HOME="ssh,aws,myapp"

  The loader transforms these:
  - DODOT_PACK_IGNORE → pack.ignore
  - DODOT_LOGGING_DEFAULT_LEVEL → logging.default_level

⏺ Update Todos
  ⎿  ☒ Create configuration system documentation walkthrough

⏺ Summary

  The configuration system provides:
  - Clean user interface with intuitive snake_case YAML
  - Flexible loading from multiple sources with clear precedence
  - Type safety through Go structs with koanf tags
  - Backward compatibility via fallback to hardcoded defaults
  - Environment variable overrides for CI/CD and scripting

  This two-layer approach keeps the user experience simple while maintaining full internal
  flexibility for system configuration.

