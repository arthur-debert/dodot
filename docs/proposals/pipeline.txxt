                        PIPELINE REFACTORING PROPOSAL


This proposal addresses the conflated execution flow in dodot by introducing
two distinct pipelines: pack pipeline and handler pipeline.


1. Motivation

    The current execution flow jumps between packages without clear boundaries:
    
        dispatcher.Dispatch()
            → packcommands.TurnOn()
                → core.Execute()
                    → core.DiscoverAndSelectPacksFS()
                    → packs.GetPackCandidatesFS()
                    → core.GetMatchesFS()
                    → rules.GetMatches()
                    → core.filterMatchesByCommandType()
                    → rules.ExecuteMatches()
                        → operations.Execute()
                → packcommands.TurnOn() (again)
                    → shell.InstallShellIntegration()
                    → packcommands.GetStatus()
    
    This mixing of concerns makes the code hard to follow and maintain. The
    core issue is that two distinct pipelines are intertwined:
    
        - Pack pipeline: discover packs → execute command → aggregate results
        - Handler pipeline: match files → filter handlers → execute operations


2. Core Design

    
    2.1 Two Distinct Pipelines
    
        Pack Pipeline (outer loop):
            Discover Packs → For Each Pack: Execute Command → Aggregate Results
        
        Handler Pipeline (inner execution for main commands):
            File Matches → Filter Active Handlers → Create Operations → Execute
        
        The pack pipeline orchestrates execution across multiple packs.
        The handler pipeline executes handlers for a single pack.
    
    
    2.2 Clean Separation
    
        Simple commands (adopt, init, add-ignore) only use the pack pipeline.
        Main commands (on, off, status) use both pipelines - the pack pipeline
        calls the handler pipeline for each pack.
        
        This separation means:
            - Pack discovery happens once
            - Pack looping happens in one place
            - Handler execution is isolated per pack
            - No backwards jumps between packages


3. Implementation Approach

    Start bottom-up with minimal changes to enable incremental migration.
    
    
    3.1 Phase 1: Extract Minimal Handler Pipeline
    
        Create a simple function that encapsulates the handler pipeline:
        
            -- go
            // pkg/handlerpipeline/execute.go
            func ExecuteHandlersForPack(
                pack types.Pack,
                filter FilterType,  // ConfigOnly, ProvisionOnly, All
                opts Options,       // DryRun, Force, FileSystem, DataStore
            ) (*Result, error) {
                // This function does the complete handler pipeline:
                matches := getMatches(pack, opts.FileSystem)
                filtered := filterHandlers(matches, filter)
                operations := createOperations(filtered)
                results := executeOperations(operations, opts)
                return buildResult(pack, results), nil
            }
            --
        
        Initially, this function just calls existing code in the right order.
        No need to rewrite the internals yet.
    
    
    3.2 Phase 2: Update One Command
    
        Modify packcommands.TurnOn to use the new function:
        
            -- go
            func TurnOn(opts OnOptions) (*types.PackCommandResult, error) {
                // Discover packs (existing code)
                packs := discoverPacks(opts)
                
                for _, pack := range packs {
                    // Link phase
                    linkResult := handlerpipeline.ExecuteHandlersForPack(
                        pack, 
                        handlerpipeline.ConfigOnly,
                        opts,
                    )
                    
                    // Provision phase
                    if !opts.NoProvision {
                        provResult := handlerpipeline.ExecuteHandlersForPack(
                            pack,
                            handlerpipeline.All,
                            opts,
                        )
                    }
                }
            }
            --
        
        This removes the complex core.Execute calls and makes the flow clear.
    
    
    3.3 Phase 3: Build Out Handler Pipeline Package
    
        Once ExecuteHandlersForPack is working, gradually move the internals:
        
            - Move match filtering logic
            - Move operation creation
            - Move execution logic
            - Create proper types and interfaces
        
        The existing code continues to work while we migrate piece by piece.
    
    
    3.4 Phase 4: Extract Pack Pipeline
    
        After handler pipeline is solid, extract the pack orchestration:
        
            -- go
            // pkg/packpipeline/execute.go
            func Execute(command Command, packNames []string, opts Options) (*Result, error) {
                packs := discoverAndSelectPacks(packNames, opts)
                results := make([]PackResult, 0, len(packs))
                
                for _, pack := range packs {
                    result := command.ExecuteForPack(pack, opts)
                    results = append(results, result)
                }
                
                return aggregateResults(results), nil
            }
            --
        
        Commands implement a simple interface:
        
            -- go
            type Command interface {
                ExecuteForPack(pack types.Pack, opts Options) PackResult
            }
            --


4. Execution Order

    After refactoring, the execution flow becomes:
    
        dispatcher.Dispatch()
            → packpipeline.Execute()
                → discover packs
                → for each pack:
                    → command.ExecuteForPack()
                        → handlerpipeline.ExecuteHandlersForPack() (for main commands)
                        → direct operations (for simple commands)
                → aggregate results
    
    Each arrow represents a clean function call with clear inputs/outputs.
    No more jumping back and forth between packages.


5. Migration Strategy

    Start with ExecuteHandlersForPack and migrate one command at a time.
    This allows us to:
    
        - Test incrementally
        - Keep existing code working
        - Learn and adjust as we go
        - Avoid big-bang refactoring
    
    The key is starting small and building confidence with each step.