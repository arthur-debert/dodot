=== Testing Guidelines for dodot ===

This document establishes the core principles and rules for writing tests in the dodot codebase.

== Test Categories ==

All tests must fall into one of these categories:

1. **Unit Tests**: Test pure business logic with no external dependencies
2. **Business Logic Integration Tests**: Test command orchestration with mocked dependencies  
3. **Output Rendering Tests**: Test data structure to text transformation
4. **CLI Parsing Tests**: Test CLI string to API call mapping
5. **DataStore Tests**: The ONLY tests allowed to use real filesystem

== Core Rules ==

=== Rule 1: No Filesystem Access ===
**NEVER** access the filesystem directly except in:
- `pkg/datastore/` internal tests
- `pkg/handlers/symlink/` tests that verify actual symlink creation
- Designated end-to-end smoke tests

Use the test utilities for all other filesystem needs.

=== Rule 2: No Shell Execution ===
**NEVER** shell out to execute commands. Test at the API boundary instead:
- Test command logic via `pkg/commands/` APIs
- Test CLI parsing separately from execution
- Test output rendering with data structures

=== Rule 3: Use Dependency Injection ===
All tests must use constructor injection for dependencies:
- Filesystem operations: inject `types.FS`
- State management: inject `types.DataStore`
- Path resolution: inject `types.PathResolver`

=== Rule 4: Test Isolation ===
Each test must be completely isolated:
- No shared state between tests
- No reliance on test execution order
- Clean up all resources (use `defer` or `t.Cleanup()`)

=== Rule 5: Clear Test Purpose ===
Each test must have a single, clear purpose:
- Test one behavior or scenario
- Name tests descriptively: `TestComponentName_Scenario_ExpectedOutcome`
- Add test type comment header (see examples below)

== Test Structure ==

Every test file must start with a comment header:

```go
// pkg/commands/link/link_test.go
// TEST TYPE: Business Logic Integration
// DEPENDENCIES: Mock DataStore, Memory FS
// PURPOSE: Test link command orchestration
```

== Common Patterns ==

=== Unit Test Pattern ===
```go
func TestHandler_ProcessFiles_Unit(t *testing.T) {
    // Arrange
    handler := NewHandler()
    input := []File{{Name: "test.txt"}}
    
    // Act
    result, err := handler.ProcessFiles(input)
    
    // Assert
    assert.NoError(t, err)
    assert.Len(t, result, 1)
}
```

=== Integration Test Pattern ===
```go
func TestLinkCommand_SinglePack_Integration(t *testing.T) {
    // Arrange
    env := testutil.NewTestEnvironment(testutil.EnvMemoryOnly)
    defer env.Cleanup()
    
    env.SetupPack("vim", testutil.PackConfig{
        Files: map[string]string{"vimrc": "content"},
    })
    
    // Act
    result, err := link.LinkPacks(link.Options{
        DotfilesRoot: env.DotfilesRoot,
        PackNames:    []string{"vim"},
    })
    
    // Assert
    assert.NoError(t, err)
    assert.Equal(t, StatusSuccess, result.Status)
}
```

=== Output Test Pattern ===
```go
func TestRenderStatus_Success_Output(t *testing.T) {
    // Arrange
    data := &ExecutionContext{
        Status: StatusSuccess,
        PackResults: []PackResult{{Name: "vim", Status: "linked"}},
    }
    
    // Act
    output := RenderStatus(data)
    
    // Assert
    assert.Contains(t, output, " vim")
    assert.NotContains(t, output, "error")
}
```

== What NOT to Do ==

=== L Direct Filesystem Access ===
```go
// WRONG - Don't do this outside pkg/datastore
_, err := os.Stat("/home/user/.vimrc")
assert.NoError(t, err)

// RIGHT - Use the API
status, err := env.DataStore.GetStatus("vim", "vimrc")
assert.Equal(t, StatusLinked, status)
```

=== L Testing Multiple Concerns ===
```go
// WRONG - Tests linking, output, and filesystem
result := LinkCommand(args)
assert.Contains(t, capturedOutput, "")
assert.True(t, fileExists(".vimrc"))

// RIGHT - Test each concern separately
// In link_test.go: test command logic
// In output_test.go: test rendering
// In datastore_test.go: test filesystem
```

=== L Environment Pollution ===
```go
// WRONG - Modifies real environment
os.Setenv("HOME", "/tmp/test")

// RIGHT - Use test environment
env := testutil.NewTestEnvironment()
// Environment automatically isolated and cleaned up
```

== Performance Guidelines ==

- Unit tests: Must complete in <10ms
- Integration tests: Must complete in <100ms  
- Full test suite: Must complete in <2s
- Use memory filesystem by default
- Only use real filesystem when testing filesystem behavior

== Debugging Tests ==

When a test fails:
1. Check the test type header - are you testing the right thing?
2. Verify dependencies - are mocks behaving correctly?
3. Check isolation - is another test affecting this one?
4. Use focused subtests: `go test -run TestName/SubTest`

== Migration Guidelines ==

When migrating old tests:
1. Identify the test's real purpose
2. Choose the appropriate test category
3. Remove filesystem dependencies (unless testing filesystem)
4. Use test utilities instead of custom setup
5. Ensure single responsibility
6. Add proper test header comment