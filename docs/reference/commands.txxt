# dodot Commands Reference

This document provides a comprehensive reference for all dodot commands, their functionality, and current implementation status.

## Command Overview

All commands follow a consistent pattern:
- Use the core pipeline system for processing
- Integrate with the datastore for state management
- Provide proper error handling and logging
- Support filesystem injection for testing

## Commands

### addignore
Creates a `.dodotignore` file in a specified pack to mark it as ignored. The command is idempotent and handles cases where the file already exists gracefully.

**Status**: Working  
**Usage**: `dodot addignore <pack-name>`

### adopt
Moves existing files from the system into a pack and creates symlinks back to their original locations. Supports force mode to overwrite existing destinations and includes rollback capabilities if symlink creation fails.

**Status**: Working  
**Usage**: `dodot adopt <pack-name> <file-paths...> [--force]`

### deprovision
Removes provisioning state for specified packs by clearing code execution handlers (homebrew, provision scripts) while preserving linking handler state. Uses the clearable handler infrastructure for consistent state management.

**Status**: Working  
**Usage**: `dodot deprovision [pack-names...]`

### fill
Adds template/placeholder files to an existing pack based on configured handlers. Creates example configuration files, scripts, and directories that users can customize for their specific needs.

**Status**: Working  
**Usage**: `dodot fill <pack-name>`

### genconfig
Generates default configuration content (commented out) and can write it to packs or current directory. Uses the same configuration template system as the init command for consistency.

**Status**: Working  
**Usage**: `dodot genconfig [--write] [pack-names...]`

### init (initialize)
Creates a new pack directory with initial structure including configuration file, README, and template files. Leverages the fill command internally to ensure consistent template generation across commands.

**Status**: Working  
**Usage**: `dodot init <pack-name>`

### link
Deploys configuration handlers only (symlinks, shell profiles, PATH modifications) without running code execution handlers. Uses the simplified pipeline approach with command mode filtering.

**Status**: Working  
**Usage**: `dodot link [pack-names...]`

### list
Discovers and lists all available packs in the dotfiles root directory. Simple command that uses the core pack discovery infrastructure.

**Status**: Working  
**Usage**: `dodot list`

### off
Comprehensive pack deactivation that runs deprovision followed by unlink to completely remove both provisioned resources and symlinks. Handles errors from each phase and reports combined results.

**Status**: Working  
**Usage**: `dodot off [pack-names...]`

### on
Full pack activation that runs link followed by provision to deploy both symlinks and provisioned resources. Aggregates results from both phases and handles partial failures gracefully.

**Status**: Working  
**Usage**: `dodot on [pack-names...]`

### provision
Runs both code execution and configuration handlers in two phases. After successful execution, automatically installs shell integration scripts and provides user instructions for enabling them in their shell configuration.

**Status**: Working with Shell Integration  
**Usage**: `dodot provision [pack-names...]`

### status
Shows deployment state of packs including special files, handler matches, and current deployment status. Uses the datastore to check actual deployment state and provides detailed file-level status information.

**Status**: Working  
**Usage**: `dodot status [pack-names...]`

### unlink
Removes deployments created by linking handlers (symlinks, PATH, shell profiles) while preserving provisioning state. Uses the clearable handler infrastructure to ensure proper cleanup and state management.

**Status**: Working  
**Usage**: `dodot unlink [pack-names...]`

## Command Relationships

### Activation Flow
- `on` = `link` + `provision`
- `init` → `fill` → `link` → `provision`

### Deactivation Flow
- `off` = `deprovision` + `unlink`
- Complete removal in reverse order

### Handler Types
- **Configuration Handlers**: symlink, shell_profile, path (handled by `link`/`unlink`)
- **Code Execution Handlers**: homebrew, install, provision (handled by `provision`/`deprovision`)

## Implementation Notes

All commands share common infrastructure:
- Pack discovery and selection via `pkg/core`
- Handler execution through the rules system
- State persistence using the datastore
- Consistent error handling with error codes
- Structured logging with verbosity levels

The codebase maintains good separation between command logic (in `pkg/commands`) and core functionality (in `pkg/core`, `pkg/handlers`, `pkg/rules`).