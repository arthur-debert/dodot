# dodot Commands Reference

This document provides a comprehensive reference for all dodot commands, their functionality, and current implementation status.

## Command Overview

All commands follow a consistent pattern:
- Use the core pipeline system for processing
- Integrate with the datastore for state management
- Provide proper error handling and logging
- Support filesystem injection for testing

## Commands

### addignore
Creates a `.dodotignore` file in a specified pack to mark it as ignored. The command is idempotent and handles cases where the file already exists gracefully.

**Status**: Working  
**Usage**: `dodot addignore <pack-name>`

### adopt
Moves existing files from the system into a pack and creates symlinks back to their original locations. Supports force mode to overwrite existing destinations and includes rollback capabilities if symlink creation fails.

**Status**: Working  
**Usage**: `dodot adopt <pack-name> <file-paths...> [--force]`


### fill
Adds template/placeholder files to an existing pack based on configured handlers. Creates example configuration files, scripts, and directories that users can customize for their specific needs.

**Status**: Working  
**Usage**: `dodot fill <pack-name>`

### genconfig
Generates default configuration content (commented out) and can write it to packs or current directory. Uses the same configuration template system as the init command for consistency.

**Status**: Working  
**Usage**: `dodot genconfig [--write] [pack-names...]`

### init (initialize)
Creates a new pack directory with initial structure including configuration file, README, and template files. Leverages the fill command internally to ensure consistent template generation across commands.

**Status**: Working  
**Usage**: `dodot init <pack-name>`


### list
Discovers and lists all available packs in the dotfiles root directory. Simple command that uses the core pack discovery infrastructure.

**Status**: Working  
**Usage**: `dodot list`

### off
The primary pack removal command. Completely removes pack deployments including all symlinks, shell integrations, PATH entries, and handler state from the data directory. This is a complete removal - no state is saved for restoration. Files in your dotfiles repository are never touched.

**Status**: Working  
**Usage**: `dodot off [pack-names...]`

### on
The primary pack deployment command. Handles all aspects of pack deployment including creating symlinks for configuration files, setting up shell integrations and PATH entries, and running installation scripts and package managers. By default, provisioning handlers only run once per pack.

**Options**:
- `--no-provision`: Skip provisioning handlers (only link files)
- `--provision-rerun`: Force re-run provisioning even if already done

**Status**: Working  
**Usage**: `dodot on [pack-names...] [--no-provision | --provision-rerun]`


### status
Shows deployment state of packs including special files, handler matches, and current deployment status. Uses the datastore to check actual deployment state and provides detailed file-level status information.

**Status**: Working  
**Usage**: `dodot status [pack-names...]`


## Command Relationships

### Activation Flow
- `init` → `fill` → `on`
- `on` handles both configuration and provisioning

### Deactivation Flow
- `off` performs complete removal
- All handler state is cleared

### Handler Types
- **Configuration Handlers**: symlink, shell_profile, path (always run)
- **Code Execution Handlers**: homebrew, install, provision (run once by default, controllable via options)

## Implementation Notes

All commands share common infrastructure:
- Pack discovery and selection via `pkg/core`
- Handler execution through the rules system
- State persistence using the datastore
- Consistent error handling with error codes
- Structured logging with verbosity levels

The codebase maintains good separation between command logic (in `pkg/commands`) and core functionality (in `pkg/core`, `pkg/handlers`, `pkg/rules`).