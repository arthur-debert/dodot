Architecture
===========

This document describes dodot's technical architecture and implementation details.

## Core Concepts

- **Dotfiles Root**: Base directory containing all dotfile packs (defaults to ~/dotfiles)
- **Pack**: A directory containing related dotfiles (vim/, git/, zsh/)
- **Rule**: Pattern-to-handler mapping with priority
- **Handler**: Converts matched files to operations (symlink, install, homebrew, shell, path)
- **Operation**: Atomic unit of work (CreateDataLink, CreateUserLink, RunCommand, CheckSentinel)
- **DataStore**: Minimal 8-method API for state management

## Processing Pipeline

dodot follows a unified execution pipeline through orchestration.Execute():

```
Commands → orchestration.Execute() → rules → handlers → operations → DataStore
```

### Unified Execution Flow

The `orchestration.Execute()` function provides a single entry point for all pack-based commands:

1. **Pack Discovery** - Scans DOTFILES_ROOT for packs
2. **Command Execution** - Executes the command for each pack via ExecuteForPack()
3. **Result Aggregation** - Collects and reports results across all packs

Each command implementation decides how to process its pack:
- Rule matching and handler execution (for on/off commands)
- Direct file operations (for adopt/init/fill)
- Status checking (for status command)

### Stage Details

### Command Execution Details

Each command implementation handles its own logic:

#### On Command Flow
1. **Rule Matching** - Scans pack files against rules
2. **Handler Grouping** - Groups matches by handler
3. **Operation Generation** - Handlers convert matches to operations
4. **Execution** - Operations execute through DataStore

#### Off Command Flow
1. **State Discovery** - Lists handlers with state for the pack
2. **State Removal** - Calls RemoveState for each handler

#### Status Command Flow
1. **Rule Matching** - Scans pack files against rules
2. **Status Checking** - Handlers check their own status via StatusChecker
3. **Display** - Shows current state for each file

## State Management

dodot uses a "double-link" architecture for state:

```
Repository File → DataStore Link → Target Location
~/dotfiles/vim/.vimrc → ~/.local/share/dodot/data/vim/symlink/.vimrc → ~/.vimrc
```

This provides:
- **State representation** without databases
- **Conflict detection** before operations
- **Clean uninstall** by removing intermediate layer
- **Operation tracking** through sentinel files

## Implementation Details

### Package Organization

```
pkg/
├── packs/         # Pack discovery, commands, and orchestration
│   ├── commands/  # Pack command implementations
│   └── orchestration/ # Pipeline execution
├── types/         # Type definitions and interfaces
├── rules/         # Rule-based matching system
├── handlers/      # Handler implementations (50-100 lines each)
├── operations/    # Operation types and executor
├── datastore/     # Minimal state management (8 methods)
├── dispatcher/    # Command dispatch logic
└── config/        # Configuration management
```

### Key Types

```go
type Rule struct {
    Pattern  string                 // e.g., "*.sh", "bin/", "!*.tmp"
    Handler  string                 // handler name
    Priority int                    // higher priority matches first
    Options  map[string]interface{} // handler-specific options
}

type Handler interface {
    Name() string
    Category() HandlerCategory
    ToOperations(matches []RuleMatch) ([]Operation, error)
}

type Operation struct {
    Type    OperationType // CreateDataLink, CreateUserLink, RunCommand, CheckSentinel
    Pack    string
    Handler string
    Source  string
    Target  string
    Command string
}

type DataStore interface {
    CreateDataLink(pack, handlerName, sourceFile string) (string, error)
    CreateUserLink(datastorePath, userPath string) error
    RunAndRecord(pack, handlerName, command, sentinel string) error
    HasSentinel(pack, handlerName, sentinel string) (bool, error)
    RemoveState(pack, handlerName string) error
    HasHandlerState(pack, handlerName string) (bool, error)
    ListPackHandlers(pack string) ([]string, error)
    ListHandlerSentinels(pack, handlerName string) ([]string, error)
}
```

## Rules System

The rules system provides simple, declarative file matching:

### Pattern Conventions

- `install.sh` - Exact filename match
- `*.sh` - Glob pattern match
- `bin/` - Directory match (trailing slash)
- `!*.tmp` - Exclusion rule (leading !)
- `*` - Catchall pattern

### Rule Processing

1. **Exclusions first** - Files matching !patterns are skipped
2. **Priority order** - Higher priority rules match first
3. **First match wins** - Once matched, no further rules apply

### Example Configuration

```toml
[[rules]]
pattern = "install.sh"
handler = "install"
priority = 90

[[rules]]
pattern = "*.sh"
handler = "shell"
priority = 80

[[rules]]
pattern = "*"
handler = "symlink"
priority = 0
```

## CLI Architecture

The CLI layer follows strict design principles:

### Thin CLI Layer

- **Commands** only parse arguments and call the dispatcher
- **Business logic** lives in pkg/packs/commands and handlers
- **No direct handler knowledge** in CLI commands
- **Clear boundaries** between layers

### Command Flow

```go
// Handler-based commands use orchestration.Execute()
result, err := orchestration.Execute(command, packNames, orchestration.Options{
    DotfilesRoot: opts.DotfilesRoot,
    DryRun:       opts.DryRun,
    Force:        opts.Force,
    FileSystem:   filesystem.NewOS(),
    DataStore:    dataStore,
    Paths:        paths.New(),
})

// Non-handler commands use domain methods
pack.AdoptFile(sourceFile, targetName)  // For adopt command
dataStore.RemoveState(pack, handler)     // For removal operations
```

### Package Organization

```
cmd/dodot/          # Cobra CLI layer
├── commands/       # CLI command definitions
│   ├── on/         # Command structure and help
│   ├── off/
│   ├── status/
│   └── ...
└── root.go         # Command routing to dispatcher

pkg/
├── dispatcher/     # Routes CLI to implementations
└── packs/
    └── commands/   # Command implementations
        ├── on.go       # Implements orchestration.Command
        ├── off.go
        ├── status.go
        └── ...
```

### Unified Output System

```go
// Terminal output with colors/tables
renderer := output.NewTerminalRenderer()

// JSON output for scripting
renderer := output.NewJSONRenderer()

// Text output for logs
renderer := output.NewTextRenderer()
```

## Component Responsibilities

### CLI Commands (cmd/dodot/commands)
- **Role**: Command structure and help text
- **Responsibilities**: Define cobra commands with usage/examples
- **What they DON'T do**: Contain any business logic

### Dispatcher (pkg/dispatcher)
- **Role**: Bridge between CLI and command implementations
- **Responsibilities**: Route CLI commands to appropriate implementations
- **Key function**: Creates command instances based on command name
- **What it does**: Decouples CLI from business logic implementations

### Command Implementations (pkg/packs/commands)
- **Role**: Business logic for pack commands
- **Responsibilities**: Implement orchestration.Command interface
- **Handler commands**: Execute operations via handlers
- **Non-handler commands**: Use Pack methods or DataStore directly
- **What they DON'T do**: Handle CLI parsing, know about cobra

### Packs/Orchestration (pkg/packs/orchestration)
- **Role**: Unified execution pipeline
- **Key function**: orchestration.Execute() orchestrates the entire flow
- **Responsibilities**: Pack discovery, command execution per pack
- **Components**: Execute, ExecuteSingle

### Rules (pkg/rules)
- **Role**: Bridge between matches and execution
- **Key function**: rules.ExecuteMatches() converts matches to operations
- **Responsibilities**: Group matches by handler, determine execution order, invoke handlers, execute via DataStore
- **Components**: GetMatches, ExecuteMatches, GroupMatchesByHandler, GetHandlerExecutionOrder

### Handlers (pkg/handlers)  
- **Role**: File-specific operation generators
- **Responsibilities**: Convert file matches to operations (symlink, homebrew, shell, path, install)
- **Used by**: Handler-related commands (on/off/link/unlink/provision/deprovision)
- **Size**: 50-100 lines each, focused on single concern

### Packs (pkg/types/pack.go)
- **Role**: Pack management domain object
- **Responsibilities**: Pack operations (init, fill, adopt, addignore), guardian methods for safe manipulation
- **What they do**: Know what needs to be created and where, create files within pack boundaries
- **Used by**: Pack-related commands (init, fill, adopt, addignore)

### DataStore (pkg/datastore)
- **Role**: Operations execution abstraction
- **Responsibilities**: Execute operations via 8-method API, state management
- **Interface**: CreateDataLink, CreateUserLink, RunAndRecord, HasSentinel, RemoveState, HasHandlerState, ListPackHandlers, ListHandlerSentinels
- **Used by**: All commands that need file operations

### Operations & Executor
- **Operations**: Data structures with type, pack, handler, source, target, command
- **Executor**: Orchestrate operation execution with dry-run support

## Performance Considerations

- **Lazy evaluation**: Only process requested packs
- **Parallel discovery**: Scan packs concurrently
- **Minimal I/O**: Cache filesystem operations
- **Early termination**: Stop on first error in dry-run

## Architectural Principles

### Unified Execution
- **Single entry point**: All pack-based commands use orchestration.Execute()
- **No business logic in CLI**: Commands are thin orchestrators only
- **Proper abstractions**: Commands → Orchestration → Rules → Handlers → Operations → DataStore
- **No bypassing**: Never skip abstraction layers or access handlers directly

### Separation of Concerns
- **Handler commands**: on, off use orchestration.Execute() for handler operations
- **Pack commands**: init, fill, adopt use Pack guardian methods
- **State commands**: unlink, deprovision use DataStore.RemoveState()
- **Query commands**: list, status use discovery functions

## Error Philosophy

- **Fail fast**: Stop on first error
- **Clear messages**: Include context and suggestions
- **Error codes**: Stable identifiers for testing
- **Recovery hints**: Tell users how to fix issues