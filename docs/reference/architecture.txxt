Architecture
===========

This document describes dodot's technical architecture and implementation details.

## Core Concepts

- **Dotfiles Root**: Base directory containing all dotfile packs (defaults to ~/dotfiles)
- **Pack**: A directory containing related dotfiles (vim/, git/, zsh/)
- **Rule**: Pattern-to-handler mapping with priority
- **Handler**: Converts matched files to operations (symlink, provision, brew, shell)
- **Operation**: Atomic unit of work (CreateDataLink, CreateUserLink, RunCommand, CheckSentinel)
- **DataStore**: Minimal 5-method API for state management

## Processing Pipeline

dodot follows a predictable four-stage pipeline:

```
1. Discovery → 2. Matching → 3. Generation → 4. Execution
```

### Stage 1: Discovery (GetPacks)
- Scans DOTFILES_ROOT for pack directories
- Applies ignore patterns from configuration
- Returns ordered list of packs with metadata

### Stage 2: Matching (GetMatches)
- For each pack, scans files against rules
- Rules use simple patterns: *.sh, bin/, !*.tmp
- Returns list of matches with handler assignments

### Stage 3: Generation (ToOperations)
- Matched files invoke their assigned handlers
- Handlers convert matches to simple operations
- Operations are just data: type, pack, handler, source, target

### Stage 4: Execution (Execute)
- Operations execute through minimal DataStore API
- Only 4 operation types: CreateDataLink, CreateUserLink, RunCommand, CheckSentinel
- Results are tracked and reported

## State Management

dodot uses a "double-link" architecture for state:

```
Repository File → DataStore Link → Target Location
~/dotfiles/vim/.vimrc → ~/.local/share/dodot/links/.vimrc → ~/.vimrc
```

This provides:
- **State representation** without databases
- **Conflict detection** before operations
- **Clean uninstall** by removing intermediate layer
- **Operation tracking** through sentinel files

## Implementation Details

### Package Organization

```
pkg/
├── core/          # Pipeline functions (GetPacks, etc.)
├── types/         # Type definitions and interfaces
├── rules/         # Rule-based matching system
├── handlers/      # Handler implementations (50-100 lines each)
├── operations/    # Operation types and executor
├── datastore/     # Minimal state management (5 methods)
└── config/        # Configuration management
```

### Key Types

```go
type Rule struct {
    Pattern  string                 // e.g., "*.sh", "bin/", "!*.tmp"
    Handler  string                 // handler name
    Priority int                    // higher priority matches first
    Options  map[string]interface{} // handler-specific options
}

type Handler interface {
    Name() string
    Category() HandlerCategory
    ToOperations(matches []RuleMatch) ([]Operation, error)
}

type Operation struct {
    Type    OperationType // CreateDataLink, CreateUserLink, RunCommand, CheckSentinel
    Pack    string
    Handler string
    Source  string
    Target  string
    Command string
}

type DataStore interface {
    CreateDataLink(pack, handlerName, sourceFile string) (string, error)
    CreateUserLink(datastorePath, userPath string) error
    RunAndRecord(pack, handlerName, command, sentinel string) error
    HasSentinel(pack, handlerName, sentinel string) (bool, error)
    RemoveState(pack, handlerName string) error
}
```

## Rules System

The rules system provides simple, declarative file matching:

### Pattern Conventions

- `install.sh` - Exact filename match
- `*.sh` - Glob pattern match
- `bin/` - Directory match (trailing slash)
- `!*.tmp` - Exclusion rule (leading !)
- `*` - Catchall pattern

### Rule Processing

1. **Exclusions first** - Files matching !patterns are skipped
2. **Priority order** - Higher priority rules match first
3. **First match wins** - Once matched, no further rules apply

### Example Configuration

```toml
[[rules]]
pattern = "install.sh"
handler = "install"
priority = 90

[[rules]]
pattern = "*.sh"
handler = "shell"
priority = 80

[[rules]]
pattern = "*"
handler = "symlink"
priority = 0
```

## CLI Architecture

The CLI layer follows strict design principles:

### Thin CLI Layer

- **Commands** only parse arguments and format output
- **Business logic** lives in pkg/, returns structured data
- **No string formatting** in core functions
- **Clear boundaries** between layers

### Package Organization

```
cmd/dodot/
├── msgs.go       # User-facing messages
├── output/       # Output formatting
├── status.go     # Status command
├── link.go       # Link command
└── unlink.go     # Unlink command
```

### Unified Output System

```go
// Terminal output with colors/tables
renderer := output.NewTerminalRenderer()

// JSON output for scripting
renderer := output.NewJSONRenderer()

// Text output for logs
renderer := output.NewTextRenderer()
```

## Component Responsibilities

- **Rules**: Match files to handlers
- **Handlers**: Convert matches to operations (50-100 lines each)
- **Operations**: Data structures with type, pack, handler, source, target, command
- **DataStore**: Execute operations via 5 methods
- **Executor**: Orchestrate operation execution with dry-run support

## Performance Considerations

- **Lazy evaluation**: Only process requested packs
- **Parallel discovery**: Scan packs concurrently
- **Minimal I/O**: Cache filesystem operations
- **Early termination**: Stop on first error in dry-run

## Error Philosophy

- **Fail fast**: Stop on first error
- **Clear messages**: Include context and suggestions
- **Error codes**: Stable identifiers for testing
- **Recovery hints**: Tell users how to fix issues