Architecture
===========

This document describes dodot's technical architecture and implementation details.

## Core Concepts

- **Dotfiles Root**: Base directory containing all dotfile packs (defaults to ~/dotfiles)
- **Pack**: A directory containing related dotfiles (vim/, git/, zsh/)
- **Rule**: Pattern-to-handler mapping with priority (replaces triggers/matchers)
- **Handler**: Action generator that processes matched files (symlink, provision, brew, shell)
- **Action**: Self-contained operation to be executed
- **DataStore**: Centralized state store for tracking operations

## Processing Pipeline

dodot follows a predictable four-stage pipeline:

```
1. Discovery → 2. Matching → 3. Generation → 4. Execution
```

### Stage 1: Discovery (GetPacks)
- Scans DOTFILES_ROOT for pack directories
- Applies ignore patterns from configuration
- Returns ordered list of packs with metadata

### Stage 2: Matching (GetMatches)
- For each pack, scans files against rules
- Rules use simple patterns: *.sh, bin/, !*.tmp
- Returns list of matches with handler assignments

### Stage 3: Generation (GetActions)
- Matched files invoke their assigned handlers
- Handlers generate actions for matched files
- Actions are self-contained with all needed data

### Stage 4: Execution (Execute/Apply)
- Actions execute through DataStore
- Operations are performed in priority order
- Results are tracked and reported

## State Management

dodot uses a "double-link" architecture for state:

```
Repository File → DataStore Link → Target Location
~/dotfiles/vim/.vimrc → ~/.local/share/dodot/links/.vimrc → ~/.vimrc
```

This provides:
- **State representation** without databases
- **Conflict detection** before operations
- **Clean uninstall** by removing intermediate layer
- **Operation tracking** through sentinel files

## Implementation Details

### Package Organization

```
pkg/
├── core/          # Pipeline functions (GetPacks, etc.)
├── types/         # Type definitions and interfaces
├── rules/         # Rule-based matching system
├── handlers/      # Handler implementations
├── actions/       # Action types
├── datastore/     # State management
└── config/        # Configuration management
```

### Key Types

```go
type Rule struct {
    Pattern  string                 // e.g., "*.sh", "bin/", "!*.tmp"
    Handler  string                 // handler name
    Priority int                    // higher priority matches first
    Options  map[string]interface{} // handler-specific options
}

type Handler interface {
    GenerateActions(pack Pack, files []string) ([]Action, error)
}

type Action interface {
    Execute(ds DataStore) error
    Type() string
}
```

## Rules System

The rules system provides simple, declarative file matching:

### Pattern Conventions

- `install.sh` - Exact filename match
- `*.sh` - Glob pattern match
- `bin/` - Directory match (trailing slash)
- `!*.tmp` - Exclusion rule (leading !)
- `*` - Catchall pattern

### Rule Processing

1. **Exclusions first** - Files matching !patterns are skipped
2. **Priority order** - Higher priority rules match first
3. **First match wins** - Once matched, no further rules apply

### Example Configuration

```toml
[[rules]]
pattern = "install.sh"
handler = "install"
priority = 90

[[rules]]
pattern = "*.sh"
handler = "shell"
priority = 80

[[rules]]
pattern = "*"
handler = "symlink"
priority = 0
```

## CLI Architecture

The CLI layer follows strict design principles:

### Thin CLI Layer

- **Commands** only parse arguments and format output
- **Business logic** lives in pkg/, returns structured data
- **No string formatting** in core functions
- **Clear boundaries** between layers

### Package Organization

```
cmd/dodot/
├── msgs.go       # User-facing messages
├── output/       # Output formatting
├── status.go     # Status command
├── link.go       # Link command
└── unlink.go     # Unlink command
```

### Unified Output System

```go
// Terminal output with colors/tables
renderer := output.NewTerminalRenderer()

// JSON output for scripting
renderer := output.NewJSONRenderer()

// Text output for logs
renderer := output.NewTextRenderer()
```

## Design Benefits

### Separation of Concerns
Each component has a single responsibility:
- Triggers: Detect files
- Handlers: Generate actions
- Actions: Execute operations
- DataStore: Manage state

### Pure Functions
Handlers and triggers are stateless:
- Easy to test
- No side effects
- Predictable behavior

### Type Safety
Strong typing throughout:
- No interface{} abuse
- Compile-time guarantees
- Self-documenting code

## Performance Considerations

- **Lazy evaluation**: Only process requested packs
- **Parallel discovery**: Scan packs concurrently
- **Minimal I/O**: Cache filesystem operations
- **Early termination**: Stop on first error in dry-run

## Error Philosophy

- **Fail fast**: Stop on first error
- **Clear messages**: Include context and suggestions
- **Error codes**: Stable identifiers for testing
- **Recovery hints**: Tell users how to fix issues