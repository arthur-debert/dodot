Architecture
===========

This document describes dodot's technical architecture and implementation details.

## Core Concepts

- **Dotfiles Root**: Base directory containing all dotfile packs (defaults to ~/dotfiles)
- **Pack**: A directory containing related dotfiles (vim/, git/, zsh/)
- **Rule**: Pattern-to-handler mapping with priority
- **Handler**: Converts matched files to operations (symlink, provision, brew, shell)
- **Operation**: Atomic unit of work (CreateDataLink, CreateUserLink, RunCommand, CheckSentinel)
- **DataStore**: Minimal 5-method API for state management

## Processing Pipeline

dodot follows a unified execution pipeline through core.Execute():

```
Commands → core.Execute() → rules → handlers → operations → DataStore
```

### Unified Execution Flow

The `core.Execute()` function provides a single entry point for all handler-based commands:

1. **Pack Discovery** - Scans DOTFILES_ROOT for packs
2. **Rule Matching** - Matches files against rules  
3. **Command Filtering** - Filters matches by command type (link, provision, etc.)
4. **Handler Execution** - Executes handlers via rules.ExecuteMatches()
5. **DataStore Operations** - Performs actual filesystem changes

### Command Types

- **CommandLink**: Configuration handlers only (symlink, shell, path)
- **CommandProvision**: All handlers (code execution first, then configuration)
- **CommandUnlink**: Removes configuration state via DataStore.RemoveState()
- **CommandDeprovision**: Removes provisioning state via DataStore.RemoveState()

### Stage Details

#### Stage 1: Discovery (DiscoverAndSelectPacks)
- Scans DOTFILES_ROOT for pack directories
- Applies ignore patterns from configuration
- Returns ordered list of packs with metadata

#### Stage 2: Matching (GetMatches)
- For each pack, scans files against rules
- Rules use simple patterns: *.sh, bin/, !*.tmp
- Returns list of matches with handler assignments

#### Stage 3: Generation (rules.ExecuteMatches)
- Groups matches by handler type
- Determines execution order (code handlers before config handlers)
- Converts matches to operations via handler.ToOperations()
- Executes operations through DataStore

#### Stage 4: Execution (DataStore)
- Operations execute through minimal DataStore API
- Only 4 operation types: CreateDataLink, CreateUserLink, RunCommand, CheckSentinel
- Results are tracked and reported

## State Management

dodot uses a "double-link" architecture for state:

```
Repository File → DataStore Link → Target Location
~/dotfiles/vim/.vimrc → ~/.local/share/dodot/links/.vimrc → ~/.vimrc
```

This provides:
- **State representation** without databases
- **Conflict detection** before operations
- **Clean uninstall** by removing intermediate layer
- **Operation tracking** through sentinel files

## Implementation Details

### Package Organization

```
pkg/
├── core/          # Pipeline functions (Execute, DiscoverAndSelectPacks, GetMatches)
├── types/         # Type definitions and interfaces
├── rules/         # Rule-based matching system with ExecuteMatches
├── handlers/      # Handler implementations (50-100 lines each)
├── operations/    # Operation types and executor
├── datastore/     # Minimal state management (5 methods)
├── commands/      # Command implementations (thin orchestrators)
└── config/        # Configuration management
```

### Key Types

```go
type Rule struct {
    Pattern  string                 // e.g., "*.sh", "bin/", "!*.tmp"
    Handler  string                 // handler name
    Priority int                    // higher priority matches first
    Options  map[string]interface{} // handler-specific options
}

type Handler interface {
    Name() string
    Category() HandlerCategory
    ToOperations(matches []RuleMatch) ([]Operation, error)
}

type Operation struct {
    Type    OperationType // CreateDataLink, CreateUserLink, RunCommand, CheckSentinel
    Pack    string
    Handler string
    Source  string
    Target  string
    Command string
}

type DataStore interface {
    CreateDataLink(pack, handlerName, sourceFile string) (string, error)
    CreateUserLink(datastorePath, userPath string) error
    RunAndRecord(pack, handlerName, command, sentinel string) error
    HasSentinel(pack, handlerName, sentinel string) (bool, error)
    RemoveState(pack, handlerName string) error
}
```

## Rules System

The rules system provides simple, declarative file matching:

### Pattern Conventions

- `install.sh` - Exact filename match
- `*.sh` - Glob pattern match
- `bin/` - Directory match (trailing slash)
- `!*.tmp` - Exclusion rule (leading !)
- `*` - Catchall pattern

### Rule Processing

1. **Exclusions first** - Files matching !patterns are skipped
2. **Priority order** - Higher priority rules match first
3. **First match wins** - Once matched, no further rules apply

### Example Configuration

```toml
[[rules]]
pattern = "install.sh"
handler = "install"
priority = 90

[[rules]]
pattern = "*.sh"
handler = "shell"
priority = 80

[[rules]]
pattern = "*"
handler = "symlink"
priority = 0
```

## CLI Architecture

The CLI layer follows strict design principles:

### Thin CLI Layer

- **Commands** only parse arguments and call core.Execute() or domain methods
- **Business logic** lives in pkg/core, pkg/rules, and handlers
- **No direct handler knowledge** in commands
- **Clear boundaries** between layers

### Command Flow

```go
// Handler-based commands use core.Execute()
ctx, err := core.Execute(core.CommandLink, core.ExecuteOptions{
    DotfilesRoot: opts.DotfilesRoot,
    PackNames:    opts.PackNames,
    DryRun:       opts.DryRun,
    Force:        opts.Force,
    Confirmer:    confirmer,
    FileSystem:   filesystem.NewOS(),
})

// Non-handler commands use domain methods
pack.AdoptFile(sourceFile, targetName)  // For adopt command
dataStore.RemoveState(pack, handler)     // For unlink/deprovision
```

### Package Organization

```
cmd/dodot/          # Cobra CLI layer
├── commands.go     # Command registration
└── root.go         # Root command setup

pkg/commands/       # Command implementations
├── link/           # Uses core.Execute(CommandLink)
├── provision/      # Uses core.Execute(CommandProvision)
├── unlink/         # Uses DataStore.RemoveState()
├── deprovision/    # Uses DataStore.RemoveState()
├── adopt/          # Uses Pack.AdoptFile()
├── init/           # Uses Pack methods
└── ...             # Other commands
```

### Unified Output System

```go
// Terminal output with colors/tables
renderer := output.NewTerminalRenderer()

// JSON output for scripting
renderer := output.NewJSONRenderer()

// Text output for logs
renderer := output.NewTextRenderer()
```

## Component Responsibilities

### Commands (pkg/commands)
- **Role**: Thin orchestration layer
- **Responsibilities**: Parse/validate options, call core.Execute() or domain methods
- **Handler commands**: Use core.Execute() with appropriate CommandType
- **Non-handler commands**: Use Pack guardian methods or DataStore directly
- **What they DON'T do**: Contain business logic, know handler internals, bypass abstractions

### Core (pkg/core)
- **Role**: Unified execution pipeline
- **Key function**: core.Execute() orchestrates the entire flow
- **Responsibilities**: Pack discovery, rule matching, command filtering, delegation to rules
- **Components**: Execute, DiscoverAndSelectPacks, GetMatches, FilterMatchesByHandlerCategory

### Rules (pkg/rules)
- **Role**: Bridge between matches and execution
- **Key function**: rules.ExecuteMatches() converts matches to operations
- **Responsibilities**: Group matches by handler, determine execution order, invoke handlers, execute via DataStore
- **Components**: GetMatches, ExecuteMatches, GroupMatchesByHandler, GetHandlerExecutionOrder

### Handlers (pkg/handlers)  
- **Role**: File-specific operation generators
- **Responsibilities**: Convert file matches to operations (symlink, homebrew, shell_profile, etc.)
- **Used by**: Handler-related commands (on/off/link/unlink/provision/deprovision)
- **Size**: 50-100 lines each, focused on single concern

### Packs (pkg/types/pack.go)
- **Role**: Pack management domain object
- **Responsibilities**: Pack operations (init, fill, adopt, addignore), guardian methods for safe manipulation
- **What they do**: Know what needs to be created and where, create files within pack boundaries
- **Used by**: Pack-related commands (init, fill, adopt, addignore)

### DataStore (pkg/datastore)
- **Role**: Operations execution abstraction
- **Responsibilities**: Execute operations via 5-method API, state management
- **Interface**: CreateDataLink, CreateUserLink, RunAndRecord, HasSentinel, RemoveState
- **Used by**: All commands that need file operations

### Operations & Executor
- **Operations**: Data structures with type, pack, handler, source, target, command
- **Executor**: Orchestrate operation execution with dry-run support

## Performance Considerations

- **Lazy evaluation**: Only process requested packs
- **Parallel discovery**: Scan packs concurrently
- **Minimal I/O**: Cache filesystem operations
- **Early termination**: Stop on first error in dry-run

## Architectural Principles

### Unified Execution
- **Single entry point**: All handler-based commands use core.Execute()
- **No business logic in commands**: Commands are thin orchestrators only
- **Proper abstractions**: Commands → Core → Rules → Handlers → Operations → DataStore
- **No bypassing**: Never skip abstraction layers or access handlers directly

### Separation of Concerns
- **Handler commands**: link, provision use core.Execute() for handler operations
- **Pack commands**: init, fill, adopt use Pack guardian methods
- **State commands**: unlink, deprovision use DataStore.RemoveState()
- **Query commands**: list, status use discovery functions

## Error Philosophy

- **Fail fast**: Stop on first error
- **Clear messages**: Include context and suggestions
- **Error codes**: Stable identifiers for testing
- **Recovery hints**: Tell users how to fix issues