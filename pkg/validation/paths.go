package validation

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/arthur-debert/dodot/pkg/config"
	"github.com/arthur-debert/dodot/pkg/errors"
	"github.com/arthur-debert/dodot/pkg/logging"
	"github.com/arthur-debert/dodot/pkg/paths"
	"github.com/arthur-debert/dodot/pkg/types"
	"github.com/rs/zerolog"
)

// PathValidator provides path validation for operations with context about where validation failed
type PathValidator struct {
	logger            zerolog.Logger
	paths             *paths.Paths
	allowHomeSymlinks bool
	config            *config.Config
}

// NewPathValidator creates a new path validator with the given configuration
func NewPathValidator(p *paths.Paths, allowHomeSymlinks bool, cfg *config.Config) *PathValidator {
	if cfg == nil {
		cfg = config.Default()
	}

	return &PathValidator{
		logger:            logging.GetLogger("validation.paths"),
		paths:             p,
		allowHomeSymlinks: allowHomeSymlinks,
		config:            cfg,
	}
}

// ValidateOperations validates a list of operations, providing context about which pack/powerup generated invalid operations
func (v *PathValidator) ValidateOperations(operations []types.Operation) error {
	for i, op := range operations {
		if err := v.ValidateOperation(op); err != nil {
			// Add context about where this operation came from
			context := ""
			if op.Pack != "" {
				context += fmt.Sprintf("pack=%s", op.Pack)
			}
			if op.PowerUp != "" {
				if context != "" {
					context += ", "
				}
				context += fmt.Sprintf("powerup=%s", op.PowerUp)
			}
			if context != "" {
				context = fmt.Sprintf(" (generated by %s)", context)
			}

			return errors.Wrapf(err, errors.ErrActionExecute,
				"operation %d failed validation%s: %s", i, context, op.Description)
		}
	}
	return nil
}

// ValidateOperation validates a single operation
func (v *PathValidator) ValidateOperation(op types.Operation) error {
	// Skip non-mutating operations
	if op.Type == types.OperationReadFile || op.Type == types.OperationChecksum {
		v.logger.Debug().Str("type", string(op.Type)).Msg("Skipping validation for non-mutating operation")
		return nil
	}

	// Skip execute operations - they don't have filesystem paths to validate
	if op.Type == types.OperationExecute {
		return nil
	}

	// Validate target path for all filesystem operations
	if op.Target != "" {
		if err := v.validateSafePath(op.Target); err != nil {
			return errors.Wrapf(err, errors.ErrInvalidInput,
				"invalid target path for %s operation", op.Type)
		}
	}

	// Special validation for symlinks
	if op.Type == types.OperationCreateSymlink {
		if op.Source == "" || op.Target == "" {
			return errors.New(errors.ErrInvalidInput, "symlink operation requires source and target")
		}
		if err := v.validateSymlinkPath(op.Target, op.Source); err != nil {
			return errors.Wrap(err, errors.ErrInvalidInput, "invalid symlink paths")
		}
	}

	return nil
}

// validateSafePath ensures the path is within dodot-controlled directories
// This is extracted from SynthfsExecutor.validateSafePath
func (v *PathValidator) validateSafePath(path string) error {
	if v.paths == nil {
		return errors.New(errors.ErrInternal, "paths not initialized")
	}

	// Normalize the path
	normalizedPath, err := filepath.Abs(path)
	if err != nil {
		return errors.Wrapf(err, errors.ErrInvalidInput,
			"failed to normalize path: %s", path)
	}

	// Also try to resolve symlinks in the path (for macOS /var -> /private/var)
	resolvedPath := normalizedPath
	// Only resolve if parent directory exists
	if parentDir := filepath.Dir(normalizedPath); parentDir != "" {
		if resolvedParent, err := filepath.EvalSymlinks(parentDir); err == nil {
			resolvedPath = filepath.Join(resolvedParent, filepath.Base(normalizedPath))
		}
	}

	// Check if the path is within any of the safe directories
	safeDirectories := []string{
		v.paths.DotfilesRoot(), // Allow operations in dotfiles root for init/fill
		v.paths.DataDir(),
		v.paths.ConfigDir(),
		v.paths.CacheDir(),
		v.paths.StateDir(),
		// All subdirectories under DataDir are safe
		v.paths.DeployedDir(),
		v.paths.BackupsDir(),
		v.paths.HomebrewDir(),
		v.paths.InstallDir(),
		v.paths.ShellDir(),
		v.paths.TemplatesDir(),
	}

	for _, safeDir := range safeDirectories {
		// Resolve symlinks in safe directory path for comparison
		resolvedSafeDir := safeDir
		if resolved, err := filepath.EvalSymlinks(safeDir); err == nil {
			resolvedSafeDir = resolved
		}

		if isPathWithin(normalizedPath, safeDir) || isPathWithin(normalizedPath, resolvedSafeDir) ||
			isPathWithin(resolvedPath, safeDir) || isPathWithin(resolvedPath, resolvedSafeDir) {
			v.logger.Debug().
				Str("path", normalizedPath).
				Str("safeDir", safeDir).
				Msg("Path validated as safe")
			return nil
		}
	}

	// Check if home operations are allowed and path is in home directory
	if v.allowHomeSymlinks {
		homeDir, err := paths.GetHomeDirectory()
		if err == nil && isPathWithin(normalizedPath, homeDir) {
			v.logger.Debug().
				Str("path", normalizedPath).
				Msg("Path validated as safe (home directory with allowHomeSymlinks)")
			return nil
		}
	}

	return errors.Newf(errors.ErrPermission,
		"operation target is outside dodot-controlled directories: %s", path)
}

// validateSymlinkPath validates symlink creation with special handling for home directory
// This is extracted from SynthfsExecutor.validateSymlinkPath
func (v *PathValidator) validateSymlinkPath(target, source string) error {
	// Normalize paths first
	normalizedTarget, err := filepath.Abs(target)
	if err != nil {
		return errors.Wrapf(err, errors.ErrInvalidInput,
			"failed to normalize target path: %s", target)
	}

	// Check if target is in home directory
	homeDir, err := paths.GetHomeDirectory()
	if err != nil {
		return errors.Wrap(err, errors.ErrFileAccess,
			"failed to get home directory for validation")
	}

	isInHome := isPathWithin(normalizedTarget, homeDir)

	// First check if target is in standard safe directories (but not if it's in home)
	if !isInHome {
		err := v.validateSafePath(target)
		if err == nil {
			// Target is in a safe directory, allow it
			return nil
		}
		v.logger.Debug().
			Str("target", target).
			Str("normalizedTarget", normalizedTarget).
			Err(err).
			Msg("Target not in safe directories")

		// If not in safe directory and not home, check if home symlinks are allowed
		if !v.allowHomeSymlinks {
			return errors.Newf(errors.ErrPermission,
				"symlink target is outside dodot-controlled directories: %s", target)
		}
	}

	// If we get here, target is either in home or home symlinks are allowed
	if !v.allowHomeSymlinks && isInHome {
		return errors.Newf(errors.ErrPermission,
			"symlink target is outside dodot-controlled directories: %s", target)
	}

	// Home symlinks are allowed, perform additional safety checks

	// First, validate the source is from dotfiles
	dotfilesRoot := v.paths.DotfilesRoot()
	normalizedSource, err := filepath.Abs(source)
	if err != nil {
		return errors.Wrapf(err, errors.ErrInvalidInput,
			"failed to normalize source path: %s", source)
	}

	// Source must be from either dotfiles or deployed directories
	deployedDir := v.paths.DeployedDir()
	if !isPathWithin(normalizedSource, dotfilesRoot) && !isPathWithin(normalizedSource, deployedDir) {
		return errors.Newf(errors.ErrPermission,
			"symlink source must be from dotfiles or deployed directory: %s", source)
	}

	// For macOS, handle /var -> /private/var resolution
	// Since the target may not exist yet, we need to check parent directories
	parentDir := filepath.Dir(normalizedTarget)
	if evalParent, err := filepath.EvalSymlinks(parentDir); err == nil {
		normalizedTarget = filepath.Join(evalParent, filepath.Base(normalizedTarget))
	}

	// Normalize home directory too for consistent comparison
	normalizedHome := homeDir
	if evalHome, err := filepath.EvalSymlinks(homeDir); err == nil {
		normalizedHome = evalHome
	} else {
		// If EvalSymlinks fails (e.g., directory doesn't exist),
		// try to at least make paths consistent by resolving the parent
		if homeParent := filepath.Dir(normalizedHome); homeParent != "" {
			if evalHomeParent, err := filepath.EvalSymlinks(homeParent); err == nil {
				normalizedHome = filepath.Join(evalHomeParent, filepath.Base(normalizedHome))
			}
		}
	}

	v.logger.Debug().
		Str("target", target).
		Str("normalizedTarget", normalizedTarget).
		Str("homeDir", homeDir).
		Str("normalizedHome", normalizedHome).
		Msg("Checking if target is in home directory")

	// Check if target is in home directory OR in a safe directory (for deploy symlinks)
	targetInHome := isPathWithin(normalizedTarget, normalizedHome)

	// Check if target is in a safe directory
	safeDirectories := []string{
		v.paths.DotfilesRoot(),
		v.paths.DataDir(),
		v.paths.ConfigDir(),
		v.paths.CacheDir(),
		v.paths.StateDir(),
		v.paths.DeployedDir(),
		v.paths.BackupsDir(),
		v.paths.HomebrewDir(),
		v.paths.InstallDir(),
		v.paths.ShellDir(),
		v.paths.TemplatesDir(),
	}

	targetInSafe := false
	for _, safeDir := range safeDirectories {
		if isPathWithin(normalizedTarget, safeDir) {
			targetInSafe = true
			break
		}
	}

	if !targetInHome && !targetInSafe {
		// Target must be in home directory or safe directory when allowHomeSymlinks is true
		return errors.Newf(errors.ErrPermission,
			"symlink target must be in home directory or dodot-controlled directory when using home symlinks: %s", target)
	}

	// Target is in home directory or safe directory, perform additional safety checks
	// Check for dangerous target locations (only if in home directory)
	if targetInHome {
		if err := v.validateNotSystemFile(normalizedTarget); err != nil {
			return err
		}
	}

	v.logger.Debug().
		Str("source", normalizedSource).
		Str("target", normalizedTarget).
		Bool("homeSymlinksAllowed", v.allowHomeSymlinks).
		Msg("Symlink path validated for home directory")

	return nil
}

// validateNotSystemFile ensures we're not overwriting critical system files
// This is extracted from SynthfsExecutor.validateNotSystemFile
func (v *PathValidator) validateNotSystemFile(path string) error {
	v.logger.Debug().
		Str("path", path).
		Msg("Checking if path is a protected system file")

	// Use HOME env var if set (for tests), otherwise use GetHomeDirectory
	homeDir := os.Getenv("HOME")
	if homeDir == "" {
		homeDir, _ = paths.GetHomeDirectory()
	}
	// Normalize home directory for consistent comparison
	if evalHome, err := filepath.EvalSymlinks(homeDir); err == nil {
		homeDir = evalHome
	}

	relPath, err := filepath.Rel(homeDir, path)
	if err != nil {
		// Not in home directory, can't check
		return nil
	}

	// Check if the relative path matches any protected path
	// First check exact match
	if v.config.Security.ProtectedPaths[relPath] {
		v.logger.Warn().
			Str("path", path).
			Str("relPath", relPath).
			Msg("Blocking operation on protected file")
		return errors.Newf(errors.ErrPermission,
			"cannot perform operation on protected file: %s", relPath)
	}

	// Then check if the path is within a protected directory
	for protectedPath := range v.config.Security.ProtectedPaths {
		if strings.HasPrefix(relPath, protectedPath+"/") {
			v.logger.Warn().
				Str("path", path).
				Str("relPath", relPath).
				Str("protected", protectedPath).
				Msg("Blocking operation on protected file")
			return errors.Newf(errors.ErrPermission,
				"cannot perform operation on protected file: %s", relPath)
		}
	}

	// Warn about existing files that will be replaced
	if info, err := os.Stat(path); err == nil {
		if info.Mode()&os.ModeSymlink == 0 {
			// It's a real file, not a symlink
			v.logger.Warn().
				Str("path", path).
				Bool("isDir", info.IsDir()).
				Msg("Existing file will be replaced")
		}
	}

	return nil
}

// isPathWithin checks if a path is within a parent directory
// This is extracted from SynthfsExecutor.isPathWithin
func isPathWithin(path, parent string) bool {
	// Normalize both paths
	path = filepath.Clean(path)
	parent = filepath.Clean(parent)

	// Check if path starts with parent
	rel, err := filepath.Rel(parent, path)
	if err != nil {
		return false
	}

	// If relative path starts with "..", it's outside parent
	return !strings.HasPrefix(rel, "..") && !strings.HasPrefix(rel, "/")
}
