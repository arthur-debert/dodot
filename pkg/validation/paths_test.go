package validation

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/arthur-debert/dodot/pkg/config"
	"github.com/arthur-debert/dodot/pkg/paths"
	"github.com/arthur-debert/dodot/pkg/testutil"
	"github.com/arthur-debert/dodot/pkg/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewPathValidator(t *testing.T) {
	tempDir := testutil.TempDir(t, "validation-test")
	p, err := paths.New(filepath.Join(tempDir, "dotfiles"))
	require.NoError(t, err)

	t.Run("with config", func(t *testing.T) {
		cfg := config.Default()
		validator := NewPathValidator(p, true, cfg)
		assert.NotNil(t, validator)
		assert.True(t, validator.allowHomeSymlinks)
		assert.Equal(t, cfg, validator.config)
	})

	t.Run("with nil config", func(t *testing.T) {
		validator := NewPathValidator(p, false, nil)
		assert.NotNil(t, validator)
		assert.False(t, validator.allowHomeSymlinks)
		assert.NotNil(t, validator.config) // Should get default config
	})
}

func TestPathValidator_ValidateOperations(t *testing.T) {
	tempDir := testutil.TempDir(t, "validation-test")
	t.Setenv("HOME", tempDir)

	p, err := paths.New(filepath.Join(tempDir, "dotfiles"))
	require.NoError(t, err)

	// Create required directories
	testutil.CreateDir(t, tempDir, ".local/share/dodot")

	validator := NewPathValidator(p, false, config.Default())

	t.Run("validates operations with context", func(t *testing.T) {
		ops := []types.Operation{
			{
				Type:        types.OperationCreateDir,
				Target:      filepath.Join(p.DataDir(), "test"),
				Description: "Create test directory",
				Pack:        "test-pack",
				PowerUp:     "test-powerup",
			},
			{
				Type:        types.OperationWriteFile,
				Target:      filepath.Join(p.DataDir(), "test.txt"),
				Description: "Write test file",
				Pack:        "test-pack",
				PowerUp:     "test-powerup",
			},
		}

		err := validator.ValidateOperations(ops)
		assert.NoError(t, err)
	})

	t.Run("provides context in error messages", func(t *testing.T) {
		ops := []types.Operation{
			{
				Type:        types.OperationWriteFile,
				Target:      "/invalid/path/outside/safe/dirs",
				Description: "Invalid operation",
				Pack:        "bad-pack",
				PowerUp:     "bad-powerup",
			},
		}

		err := validator.ValidateOperations(ops)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "pack=bad-pack, powerup=bad-powerup")
		assert.Contains(t, err.Error(), "operation 0 failed validation")
	})

	t.Run("handles operations without pack/powerup context", func(t *testing.T) {
		ops := []types.Operation{
			{
				Type:        types.OperationWriteFile,
				Target:      "/invalid/path",
				Description: "Invalid operation without context",
			},
		}

		err := validator.ValidateOperations(ops)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "operation 0 failed validation")
		assert.NotContains(t, err.Error(), "generated by")
	})
}

func TestPathValidator_ValidateOperation(t *testing.T) {
	tempDir := testutil.TempDir(t, "validation-test")
	t.Setenv("HOME", tempDir)

	p, err := paths.New(filepath.Join(tempDir, "dotfiles"))
	require.NoError(t, err)

	// Create required directories
	testutil.CreateDir(t, tempDir, ".local/share/dodot")

	validator := NewPathValidator(p, false, config.Default())

	t.Run("skips non-mutating operations", func(t *testing.T) {
		op := types.Operation{
			Type:   types.OperationReadFile,
			Target: "/any/path",
		}
		err := validator.ValidateOperation(op)
		assert.NoError(t, err)
	})

	t.Run("skips execute operations", func(t *testing.T) {
		op := types.Operation{
			Type:    types.OperationExecute,
			Command: "ls",
		}
		err := validator.ValidateOperation(op)
		assert.NoError(t, err)
	})

	t.Run("validates filesystem operations", func(t *testing.T) {
		op := types.Operation{
			Type:   types.OperationCreateDir,
			Target: filepath.Join(p.DataDir(), "test"),
		}
		err := validator.ValidateOperation(op)
		assert.NoError(t, err)
	})

	t.Run("requires both source and target for symlinks", func(t *testing.T) {
		op := types.Operation{
			Type:   types.OperationCreateSymlink,
			Target: filepath.Join(p.DataDir(), "test"),
			// Missing Source
		}
		err := validator.ValidateOperation(op)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "symlink operation requires source and target")
	})
}

func TestPathValidator_validateSafePath(t *testing.T) {
	tempDir := testutil.TempDir(t, "validation-test")
	t.Setenv("HOME", tempDir)

	p, err := paths.New(filepath.Join(tempDir, "dotfiles"))
	require.NoError(t, err)

	validator := NewPathValidator(p, false, config.Default())

	t.Run("allows paths in safe directories", func(t *testing.T) {
		safePaths := []string{
			filepath.Join(p.DataDir(), "test"),
			filepath.Join(p.ConfigDir(), "test"),
			filepath.Join(p.CacheDir(), "test"),
			filepath.Join(p.DeployedDir(), "test"),
			filepath.Join(p.DotfilesRoot(), "test"),
		}

		for _, path := range safePaths {
			err := validator.validateSafePath(path)
			assert.NoError(t, err, "Path should be safe: %s", path)
		}
	})

	t.Run("rejects paths outside safe directories", func(t *testing.T) {
		unsafePaths := []string{
			"/tmp/test",
			"/etc/test",
			"/var/test",
			filepath.Join(tempDir, "unsafe", "test"),
		}

		for _, path := range unsafePaths {
			err := validator.validateSafePath(path)
			assert.Error(t, err, "Path should be unsafe: %s", path)
			assert.Contains(t, err.Error(), "outside dodot-controlled directories")
		}
	})

	t.Run("allows home directory with allowHomeSymlinks", func(t *testing.T) {
		validator := NewPathValidator(p, true, config.Default())
		homePath := filepath.Join(tempDir, ".bashrc")

		err := validator.validateSafePath(homePath)
		assert.NoError(t, err)
	})

	t.Run("rejects home directory without allowHomeSymlinks", func(t *testing.T) {
		validator := NewPathValidator(p, false, config.Default())
		homePath := filepath.Join(tempDir, ".bashrc")

		err := validator.validateSafePath(homePath)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "outside dodot-controlled directories")
	})
}

func TestPathValidator_validateSymlinkPath(t *testing.T) {
	tempDir := testutil.TempDir(t, "validation-test")
	t.Setenv("HOME", tempDir)

	p, err := paths.New(filepath.Join(tempDir, "dotfiles"))
	require.NoError(t, err)

	// Create test directories
	testutil.CreateDir(t, tempDir, "dotfiles/configs")
	testutil.CreateDir(t, tempDir, ".local/share/dodot")

	validator := NewPathValidator(p, true, config.Default())

	t.Run("allows symlink from dotfiles to home", func(t *testing.T) {
		source := filepath.Join(p.DotfilesRoot(), "configs", ".bashrc")
		target := filepath.Join(tempDir, ".bashrc")

		err := validator.validateSymlinkPath(target, source)
		assert.NoError(t, err)
	})

	t.Run("allows symlink from deployed to safe directory", func(t *testing.T) {
		source := filepath.Join(p.DeployedDir(), "test")
		target := filepath.Join(p.DataDir(), "test")

		err := validator.validateSymlinkPath(target, source)
		assert.NoError(t, err)
	})

	t.Run("rejects source outside dotfiles/deployed", func(t *testing.T) {
		source := "/tmp/bad-source"
		target := filepath.Join(tempDir, ".bashrc")

		err := validator.validateSymlinkPath(target, source)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "symlink source must be from dotfiles or deployed directory")
	})

	t.Run("rejects target outside home when home symlinks not allowed", func(t *testing.T) {
		validator := NewPathValidator(p, false, config.Default())
		source := filepath.Join(p.DotfilesRoot(), "configs", ".bashrc")
		target := "/tmp/bad-target"

		err := validator.validateSymlinkPath(target, source)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "outside dodot-controlled directories")
	})
}

func TestPathValidator_ProtectedPaths(t *testing.T) {
	tempDir := testutil.TempDir(t, "protected-test")
	t.Setenv("HOME", tempDir)

	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, ".local/share/dodot")

	p, err := paths.New(dotfilesDir)
	require.NoError(t, err)

	// Create source file
	sourceFile := filepath.Join(dotfilesDir, "config")
	testutil.CreateFile(t, dotfilesDir, "config", "test content")

	validator := NewPathValidator(p, true, config.Default()) // Home symlinks enabled

	protectedPaths := []string{
		".ssh/id_rsa",
		".ssh/id_ed25519",
		".ssh/authorized_keys",
		".gnupg/private-keys-v1.d/key.key",
		".aws/credentials",
		".kube/config",
		".docker/config.json",
	}

	for _, protected := range protectedPaths {
		t.Run(protected, func(t *testing.T) {
			target := filepath.Join(tempDir, protected)

			// Create parent directory so path normalization works correctly
			parentDir := filepath.Dir(target)
			if parentDir != tempDir {
				err := os.MkdirAll(parentDir, 0755)
				require.NoError(t, err)
			}

			ops := []types.Operation{
				{
					Type:        types.OperationCreateSymlink,
					Source:      sourceFile,
					Target:      target,
					Description: "Test protected path",
					Pack:        "test",
					PowerUp:     "symlink",
				},
			}

			err := validator.ValidateOperations(ops)
			assert.Error(t, err)
			assert.Contains(t, err.Error(), "protected file")
		})
	}

	t.Run("allows non-protected paths", func(t *testing.T) {
		ops := []types.Operation{
			{
				Type:        types.OperationCreateSymlink,
				Source:      sourceFile,
				Target:      filepath.Join(tempDir, ".vimrc"),
				Description: "Test allowed path",
			},
		}

		err := validator.ValidateOperations(ops)
		assert.NoError(t, err)
	})
}

func TestIsPathWithin(t *testing.T) {
	tests := []struct {
		name     string
		path     string
		parent   string
		expected bool
	}{
		{
			name:     "path within parent",
			path:     "/home/user/dotfiles/config.txt",
			parent:   "/home/user/dotfiles",
			expected: true,
		},
		{
			name:     "path equals parent",
			path:     "/home/user/dotfiles",
			parent:   "/home/user/dotfiles",
			expected: true,
		},
		{
			name:     "path outside parent",
			path:     "/home/user/other/config.txt",
			parent:   "/home/user/dotfiles",
			expected: false,
		},
		{
			name:     "path with parent traversal",
			path:     "/home/user/dotfiles/../other/config.txt",
			parent:   "/home/user/dotfiles",
			expected: false,
		},
		{
			name:     "relative path within parent",
			path:     "./dotfiles/config.txt",
			parent:   "./dotfiles",
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isPathWithin(tt.path, tt.parent)
			assert.Equal(t, tt.expected, result)
		})
	}
}
