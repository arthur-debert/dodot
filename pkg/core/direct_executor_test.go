package core

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/arthur-debert/dodot/pkg/config"
	"github.com/arthur-debert/dodot/pkg/paths"
	"github.com/arthur-debert/dodot/pkg/testutil"
	"github.com/arthur-debert/dodot/pkg/types"
)

func TestDirectExecutor_SymlinkPowerUp(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-symlink")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file
	testutil.CreateFile(t, dotfilesDir, "vimrc", "\" Test vimrc")
	sourceFile := filepath.Join(dotfilesDir, "vimrc")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create symlink action (as would be generated by SymlinkPowerUp)
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link .vimrc to home directory",
			Source:      sourceFile,
			Target:      filepath.Join(homeDir, ".vimrc"),
			Pack:        "vim",
			PowerUpName: "symlink",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)

	// Debug: print results
	for i, r := range results {
		t.Logf("Result %d: %s -> %s (status: %s)", i, r.Operation.Source, r.Operation.Target, r.Status)
	}

	testutil.AssertTrue(t, len(results) >= 2, fmt.Sprintf("Expected at least 2 results, got %d", len(results)))

	// Verify symlinks were created
	targetLink := filepath.Join(homeDir, ".vimrc")
	testutil.AssertTrue(t, testutil.FileExists(t, targetLink), "Target symlink should exist")

	// Verify it points to the deployed link
	deployedPath := filepath.Join(p.SymlinkDir(), ".vimrc")
	testutil.AssertTrue(t, testutil.FileExists(t, deployedPath), "Deployed symlink should exist")

	// Verify the chain: target -> deployed -> source
	targetDest, err := os.Readlink(targetLink)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, deployedPath, targetDest)

	deployedDest, err := os.Readlink(deployedPath)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, sourceFile, deployedDest)
}

func TestDirectExecutor_WritePowerUp(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-write")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: false,
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create write action
	testContent := "#!/bin/bash\necho 'Hello from test'"
	actions := []types.Action{
		{
			Type:        types.ActionTypeWrite,
			Description: "Write test script",
			Target:      filepath.Join(p.InstallDir(), "test-script.sh"),
			Content:     testContent,
			Mode:        0755,
			Pack:        "test",
			PowerUpName: "install",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))

	// Verify file was created
	targetFile := filepath.Join(p.InstallDir(), "test-script.sh")
	testutil.AssertTrue(t, testutil.FileExists(t, targetFile), "File should exist")

	content := testutil.ReadFile(t, targetFile)
	testutil.AssertEqual(t, testContent, content)

	// Verify permissions
	info, err := os.Stat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, os.FileMode(0755), info.Mode().Perm())
}

func TestDirectExecutor_RunAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-run")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: false,
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create run action
	actions := []types.Action{
		{
			Type:        types.ActionTypeRun,
			Description: "Run echo command",
			Command:     "echo",
			Args:        []string{"Hello", "from test"},
			Pack:        "test",
			PowerUpName: "install",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)
}

func TestDirectExecutor_MkdirAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-mkdir")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: false,
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create mkdir action
	targetDir := filepath.Join(p.DataDir(), "test-dir", "nested")
	actions := []types.Action{
		{
			Type:        types.ActionTypeMkdir,
			Description: "Create test directory",
			Target:      targetDir,
			Mode:        0755,
			Pack:        "test",
			PowerUpName: "template",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))

	// Verify directory was created
	testutil.AssertTrue(t, testutil.DirExists(t, targetDir), "Directory should exist")
}

func TestDirectExecutor_MixedPowerUps(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-mixed")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source files
	testutil.CreateFile(t, dotfilesDir, "bashrc", "# Test bashrc")
	testutil.CreateFile(t, dotfilesDir, "install.sh", "#!/bin/bash\necho 'Installing'")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create mixed actions from different power-ups
	actions := []types.Action{
		// From SymlinkPowerUp
		{
			Type:        types.ActionTypeLink,
			Description: "Link .bashrc to home directory",
			Source:      filepath.Join(dotfilesDir, "bashrc"),
			Target:      filepath.Join(homeDir, ".bashrc"),
			Pack:        "bash",
			PowerUpName: "symlink",
			Priority:    100,
		},
		// From InstallPowerUp
		{
			Type:        types.ActionTypeCopy,
			Description: "Copy install script",
			Source:      filepath.Join(dotfilesDir, "install.sh"),
			Target:      filepath.Join(p.InstallDir(), "install.sh"),
			Pack:        "bash",
			PowerUpName: "install",
			Priority:    90,
		},
		{
			Type:        types.ActionTypeRun,
			Description: "Make install script executable",
			Command:     "chmod",
			Args:        []string{"+x", filepath.Join(p.InstallDir(), "install.sh")},
			Pack:        "bash",
			PowerUpName: "install",
			Priority:    80,
		},
		// From a hypothetical config writer
		{
			Type:        types.ActionTypeWrite,
			Description: "Write config file",
			Target:      filepath.Join(p.DataDir(), "test.conf"),
			Content:     "# Test configuration\nkey=value\n",
			Mode:        0644,
			Pack:        "config",
			PowerUpName: "config",
			Priority:    70,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)

	// Debug: print results
	for i, r := range results {
		t.Logf("Result %d: %s -> %s (status: %s)", i, r.Operation.Source, r.Operation.Target, r.Status)
	}

	// Should have results for: deploy link, target link, copy, chmod, write
	testutil.AssertTrue(t, len(results) >= 5, fmt.Sprintf("Expected at least 5 results, got %d", len(results)))

	// Verify all operations succeeded
	for i, result := range results {
		if result.Status != types.StatusReady {
			t.Errorf("Result %d failed: %v", i, result.Error)
		}
	}

	// Verify files were created
	testutil.AssertTrue(t, testutil.FileExists(t, filepath.Join(homeDir, ".bashrc")), "Bashrc symlink should exist")
	testutil.AssertTrue(t, testutil.FileExists(t, filepath.Join(p.InstallDir(), "install.sh")), "Install script should exist")
	testutil.AssertTrue(t, testutil.FileExists(t, filepath.Join(p.DataDir(), "test.conf")), "Config file should exist")

	// Verify install script is executable
	installScript := filepath.Join(p.InstallDir(), "install.sh")
	info, err := os.Stat(installScript)
	if err != nil {
		t.Logf("Install script not found at: %s", installScript)
		testutil.AssertNoError(t, err)
	}
	testutil.AssertTrue(t, info.Mode()&0111 != 0, "Install script should be executable")
}

func TestDirectExecutor_DryRun(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-dryrun")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: true, // Enable dry run
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create actions
	targetFile := filepath.Join(p.DataDir(), "test.txt")
	actions := []types.Action{
		{
			Type:        types.ActionTypeWrite,
			Description: "Write test file",
			Target:      targetFile,
			Content:     "This should not be written",
			Pack:        "test",
			PowerUpName: "test",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// Verify file was NOT created
	testutil.AssertFalse(t, testutil.FileExists(t, targetFile), "File should not exist in dry run")
}

func TestDirectExecutor_ValidationErrors(t *testing.T) {
	t.Skip("Test skipped - path validation removed during Operation elimination")
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-validation")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: false, // Disable home symlinks
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create action that should fail validation
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link to home directory (should fail)",
			Source:      "/tmp/source",
			Target:      filepath.Join(homeDir, ".vimrc"),
			Pack:        "vim",
			PowerUpName: "symlink",
			Priority:    100,
		},
	}

	// Execute - should fail validation
	_, err = executor.ExecuteActions(actions)
	testutil.AssertError(t, err)
	testutil.AssertErrorContains(t, err, "outside dodot-controlled directories")
}

func TestDirectExecutor_ForceMode(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-force")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file and existing target
	testutil.CreateFile(t, dotfilesDir, "vimrc", "\" New vimrc")
	testutil.CreateFile(t, homeDir, ".vimrc", "\" Old vimrc")
	sourceFile := filepath.Join(dotfilesDir, "vimrc")
	targetFile := filepath.Join(homeDir, ".vimrc")

	// Create execution context with force mode
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             true, // Enable force mode
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create symlink action
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Force link .vimrc to home directory",
			Source:      sourceFile,
			Target:      targetFile,
			Pack:        "vim",
			PowerUpName: "symlink",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, len(results) > 0, "Should have results")

	// Verify symlink was created (replacing the existing file)
	info, err := os.Lstat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, info.Mode()&os.ModeSymlink != 0, "Target should be a symlink")
}
