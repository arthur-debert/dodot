package core

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/arthur-debert/dodot/pkg/paths"
	"github.com/arthur-debert/dodot/pkg/powerups/homebrew"
	"github.com/arthur-debert/dodot/pkg/powerups/install"
	"github.com/arthur-debert/dodot/pkg/testutil"
	"github.com/arthur-debert/dodot/pkg/types"
)

// TestRunOncePowerUpsIntegration tests run-once power-ups with direct action creation
func TestRunOncePowerUpsIntegration(t *testing.T) {
	// Setup test environment
	tmpDir := testutil.TempDir(t, "runonce-integration")
	origDataDir := os.Getenv("DODOT_DATA_DIR")
	dataDir := filepath.Join(tmpDir, "dodot-data")
	_ = os.MkdirAll(dataDir, 0755)
	_ = os.Setenv("DODOT_DATA_DIR", dataDir)
	t.Cleanup(func() {
		_ = os.Setenv("DODOT_DATA_DIR", origDataDir)
	})

	// Create test files
	brewfilePath := filepath.Join(tmpDir, "Brewfile")
	installPath := filepath.Join(tmpDir, "install.sh")

	brewfileContent := `brew "git"`
	installContent := `#!/bin/bash
echo install`

	_ = os.WriteFile(brewfilePath, []byte(brewfileContent), 0644)
	_ = os.WriteFile(installPath, []byte(installContent), 0755)

	// Calculate checksums
	brewChecksum, err := testutil.CalculateFileChecksum(brewfilePath)
	testutil.AssertNoError(t, err)
	installChecksum, err := testutil.CalculateFileChecksum(installPath)
	testutil.AssertNoError(t, err)

	// Create actions that would be generated by power-ups
	actions := []types.Action{
		{
			Type:        types.ActionTypeBrew,
			Source:      brewfilePath,
			Pack:        "tools",
			PowerUpName: homebrew.HomebrewPowerUpName,
			Metadata: map[string]interface{}{
				"checksum": brewChecksum,
				"pack":     "tools",
			},
		},
		{
			Type:        types.ActionTypeInstall,
			Source:      installPath,
			Pack:        "tools",
			PowerUpName: install.InstallScriptPowerUpName,
			Metadata: map[string]interface{}{
				"checksum": installChecksum,
				"pack":     "tools",
			},
		},
	}

	// Create execution context with checksums
	testPaths := createTestPaths(t)

	// Test 1: First run - both actions should execute
	filtered, err := FilterRunOnceActions(actions, false, testPaths)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 2, len(filtered))

	ctx := NewExecutionContext(false, testPaths)
	ctx.ChecksumResults[brewfilePath] = brewChecksum
	ctx.ChecksumResults[installPath] = installChecksum

	// Convert to operations with context (PLANNING PHASE - no execution yet)
	ops, err := ConvertActionsToOperationsWithContext(filtered, ctx)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, len(ops) > 0, "Should have operations planned")

	// EXECUTION PHASE - Actually perform the operations
	// NOTE: This test manually simulates execution instead of using a proper executor
	// This is why it skips OperationExecute types and only handles file operations
	t.Logf("Operations planned (not executed): %d", len(ops))
	for i, op := range ops {
		t.Logf("  [%d] %s: %s", i, op.Type, op.Target)
		switch op.Type {
		case types.OperationCreateDir:
			err := os.MkdirAll(op.Target, 0755)
			testutil.AssertNoError(t, err)
		case types.OperationWriteFile:
			// Ensure parent directory exists
			_ = os.MkdirAll(filepath.Dir(op.Target), 0755)
			err := os.WriteFile(op.Target, []byte(op.Content), 0644)
			testutil.AssertNoError(t, err)
		}
	}

	// Test 2: Second run - no actions should execute
	filtered2, err := FilterRunOnceActions(actions, false, testPaths)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 0, len(filtered2))

	// Test 3: Force flag - both actions should execute
	filtered3, err := FilterRunOnceActions(actions, true, testPaths)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 2, len(filtered3))

	// Test 4: Change detection - modify Brewfile
	newBrewfileContent := brewfileContent + "\nbrew \"jq\""
	_ = os.WriteFile(brewfilePath, []byte(newBrewfileContent), 0644)

	// Update checksum in action
	newBrewChecksum, err := testutil.CalculateFileChecksum(brewfilePath)
	testutil.AssertNoError(t, err)
	actions[0].Metadata["checksum"] = newBrewChecksum

	// Should run Brewfile action only
	filtered4, err := FilterRunOnceActions(actions, false, testPaths)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(filtered4))
	testutil.AssertEqual(t, types.ActionTypeBrew, filtered4[0].Type)
}

// TestRunOncePowerUpsWithMultiplePacks tests run-once behavior across multiple packs
func TestRunOncePowerUpsWithMultiplePacks(t *testing.T) {
	// Setup test environment
	tmpDir := testutil.TempDir(t, "multipack-test")
	origDataDir := os.Getenv("DODOT_DATA_DIR")
	dataDir := filepath.Join(tmpDir, "dodot-data")
	_ = os.MkdirAll(dataDir, 0755)
	_ = os.Setenv("DODOT_DATA_DIR", dataDir)
	t.Cleanup(func() {
		_ = os.Setenv("DODOT_DATA_DIR", origDataDir)
	})

	// Create paths instance for testing
	testPaths := createTestPaths(t)

	// Create actions for multiple packs
	var actions []types.Action
	packs := []string{"tools", "dev", "network"}

	for _, pack := range packs {
		// Create a Brewfile for testing checksum
		brewfilePath := filepath.Join(tmpDir, pack+"_Brewfile")
		content := `brew "` + pack + `-tool"`
		_ = os.WriteFile(brewfilePath, []byte(content), 0644)

		checksum, err := testutil.CalculateFileChecksum(brewfilePath)
		testutil.AssertNoError(t, err)

		actions = append(actions, types.Action{
			Type:        types.ActionTypeBrew,
			Source:      brewfilePath,
			Pack:        pack,
			PowerUpName: homebrew.HomebrewPowerUpName,
			Metadata: map[string]interface{}{
				"checksum": checksum,
				"pack":     pack,
			},
		})
	}

	// All should run first time
	filtered, err := FilterRunOnceActions(actions, false, testPaths)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 3, len(filtered))

	// Create sentinel for only "tools" pack
	homebrewDir := paths.GetHomebrewDir()
	_ = os.MkdirAll(homebrewDir, 0755)

	// Find and create sentinel for tools pack
	for _, action := range actions {
		if action.Pack == "tools" {
			if checksum, ok := action.Metadata["checksum"].(string); ok {
				sentinelPath := filepath.Join(homebrewDir, "tools")
				_ = os.WriteFile(sentinelPath, []byte(checksum), 0644)
			}
		}
	}

	// Second run - only dev and network should run
	filtered2, err := FilterRunOnceActions(actions, false, testPaths)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 2, len(filtered2))

	// Verify it's the right packs
	ranPacks := make(map[string]bool)
	for _, action := range filtered2 {
		ranPacks[action.Pack] = true
	}
	testutil.AssertTrue(t, ranPacks["dev"], "dev pack should run")
	testutil.AssertTrue(t, ranPacks["network"], "network pack should run")
	testutil.AssertFalse(t, ranPacks["tools"], "tools pack should not run")
}

// BenchmarkRunOnceFiltering benchmarks filtering run-once actions
func BenchmarkRunOnceFiltering(b *testing.B) {
	// Setup
	tmpDir := b.TempDir()
	dataDir := filepath.Join(tmpDir, "dodot-data")
	_ = os.MkdirAll(dataDir, 0755)
	_ = os.Setenv("DODOT_DATA_DIR", dataDir)

	// Create a large set of actions
	var actions []types.Action
	for i := 0; i < 100; i++ {
		packName := fmt.Sprintf("pack%d", i)

		// Mix of run-once and regular actions
		switch i % 3 {
		case 0:
			actions = append(actions, types.Action{
				Type:        types.ActionTypeBrew,
				Pack:        packName,
				PowerUpName: homebrew.HomebrewPowerUpName,
				Metadata: map[string]interface{}{
					"checksum": fmt.Sprintf("checksum%d", i),
					"pack":     packName,
				},
			})
		case 1:
			actions = append(actions, types.Action{
				Type:        types.ActionTypeInstall,
				Pack:        packName,
				PowerUpName: install.InstallScriptPowerUpName,
				Metadata: map[string]interface{}{
					"checksum": fmt.Sprintf("checksum%d", i),
					"pack":     packName,
				},
			})
		default:
			actions = append(actions, types.Action{
				Type: types.ActionTypeLink,
				Pack: packName,
			})
		}
	}

	// Create some sentinel files
	homebrewDir := paths.GetHomebrewDir()
	installDir := paths.GetInstallDir()
	_ = os.MkdirAll(homebrewDir, 0755)
	_ = os.MkdirAll(installDir, 0755)

	// Mark half of the run-once actions as already executed
	for i := 0; i < 50; i += 6 {
		sentinelPath := filepath.Join(homebrewDir, fmt.Sprintf("pack%d", i))
		_ = os.WriteFile(sentinelPath, []byte(fmt.Sprintf("checksum%d", i)), 0644)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		testPaths := createTestPaths(b)
		_, _ = FilterRunOnceActions(actions, false, testPaths)
	}
}
