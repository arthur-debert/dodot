package core

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/arthur-debert/dodot/pkg/config"
	"github.com/arthur-debert/dodot/pkg/paths"
	"github.com/arthur-debert/dodot/pkg/testutil"
	"github.com/arthur-debert/dodot/pkg/types"
)

func TestDirectExecutor_SymlinkHandler(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-symlink")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file
	testutil.CreateFile(t, dotfilesDir, "vimrc", "\" Test vimrc")
	sourceFile := filepath.Join(dotfilesDir, "vimrc")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create symlink action (as would be generated by SymlinkHandler)
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link .vimrc to home directory",
			Source:      sourceFile,
			Target:      filepath.Join(homeDir, ".vimrc"),
			Pack:        "vim",
			HandlerName: "symlink",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)

	// Debug: print results
	for i, r := range results {
		t.Logf("Result %d: %s -> %s (status: %s)", i, r.Action.Source, r.Action.Target, r.Status)
	}

	testutil.AssertTrue(t, len(results) == 1, fmt.Sprintf("Expected 1 result per action, got %d", len(results)))

	// Verify symlinks were created
	targetLink := filepath.Join(homeDir, ".vimrc")
	testutil.AssertTrue(t, testutil.FileExists(t, targetLink), "Target symlink should exist")

	// Verify it points to the deployed link
	deployedPath := filepath.Join(p.SymlinkDir(), ".vimrc")
	testutil.AssertTrue(t, testutil.FileExists(t, deployedPath), "Deployed symlink should exist")

	// Verify the chain: target -> deployed -> source
	targetDest, err := os.Readlink(targetLink)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, deployedPath, targetDest)

	deployedDest, err := os.Readlink(deployedPath)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, sourceFile, deployedDest)
}

func TestDirectExecutor_WriteHandler(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-write")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: false,
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create write action
	testContent := "#!/bin/bash\necho 'Hello from test'"
	actions := []types.Action{
		{
			Type:        types.ActionTypeWrite,
			Description: "Write test script",
			Target:      filepath.Join(p.InstallDir(), "test-script.sh"),
			Content:     testContent,
			Mode:        0755,
			Pack:        "test",
			HandlerName: "install",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))

	// Verify file was created
	targetFile := filepath.Join(p.InstallDir(), "test-script.sh")
	testutil.AssertTrue(t, testutil.FileExists(t, targetFile), "File should exist")

	content := testutil.ReadFile(t, targetFile)
	testutil.AssertEqual(t, testContent, content)

	// Verify permissions
	info, err := os.Stat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, os.FileMode(0755), info.Mode().Perm())
}

func TestDirectExecutor_RunAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-run")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: false,
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create run action
	actions := []types.Action{
		{
			Type:        types.ActionTypeRun,
			Description: "Run echo command",
			Command:     "echo",
			Args:        []string{"Hello", "from test"},
			Pack:        "test",
			HandlerName: "install",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)
}

func TestDirectExecutor_MkdirAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-mkdir")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: false,
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create mkdir action
	targetDir := filepath.Join(p.DataDir(), "test-dir", "nested")
	actions := []types.Action{
		{
			Type:        types.ActionTypeMkdir,
			Description: "Create test directory",
			Target:      targetDir,
			Mode:        0755,
			Pack:        "test",
			HandlerName: "template",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))

	// Verify directory was created
	testutil.AssertTrue(t, testutil.DirExists(t, targetDir), "Directory should exist")
}

func TestDirectExecutor_MixedHandlers(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-mixed")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source files
	testutil.CreateFile(t, dotfilesDir, "bashrc", "# Test bashrc")
	testutil.CreateFile(t, dotfilesDir, "install.sh", "#!/bin/bash\necho 'Installing'")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create mixed actions from different power-ups
	actions := []types.Action{
		// From SymlinkHandler
		{
			Type:        types.ActionTypeLink,
			Description: "Link .bashrc to home directory",
			Source:      filepath.Join(dotfilesDir, "bashrc"),
			Target:      filepath.Join(homeDir, ".bashrc"),
			Pack:        "bash",
			HandlerName: "symlink",
			Priority:    100,
		},
		// From InstallHandler
		{
			Type:        types.ActionTypeCopy,
			Description: "Copy install script",
			Source:      filepath.Join(dotfilesDir, "install.sh"),
			Target:      filepath.Join(p.InstallDir(), "install.sh"),
			Pack:        "bash",
			HandlerName: "install",
			Priority:    90,
		},
		{
			Type:        types.ActionTypeRun,
			Description: "Make install script executable",
			Command:     "chmod",
			Args:        []string{"+x", filepath.Join(p.InstallDir(), "install.sh")},
			Pack:        "bash",
			HandlerName: "install",
			Priority:    80,
		},
		// From a hypothetical config writer
		{
			Type:        types.ActionTypeWrite,
			Description: "Write config file",
			Target:      filepath.Join(p.DataDir(), "test.conf"),
			Content:     "# Test configuration\nkey=value\n",
			Mode:        0644,
			Pack:        "config",
			HandlerName: "config",
			Priority:    70,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)

	// Debug: print results
	for i, r := range results {
		t.Logf("Result %d: %s -> %s (status: %s)", i, r.Action.Source, r.Action.Target, r.Status)
	}

	// Should have results for: link action, copy action, run action, write action (4 actions total)
	testutil.AssertTrue(t, len(results) == 4, fmt.Sprintf("Expected 4 results (one per action), got %d", len(results)))

	// Verify all operations succeeded
	for i, result := range results {
		if result.Status != types.StatusReady {
			t.Errorf("Result %d failed: %v", i, result.Error)
		}
	}

	// Verify files were created
	testutil.AssertTrue(t, testutil.FileExists(t, filepath.Join(homeDir, ".bashrc")), "Bashrc symlink should exist")
	testutil.AssertTrue(t, testutil.FileExists(t, filepath.Join(p.InstallDir(), "install.sh")), "Install script should exist")
	testutil.AssertTrue(t, testutil.FileExists(t, filepath.Join(p.DataDir(), "test.conf")), "Config file should exist")

	// Verify install script is executable
	installScript := filepath.Join(p.InstallDir(), "install.sh")
	info, err := os.Stat(installScript)
	if err != nil {
		t.Logf("Install script not found at: %s", installScript)
		testutil.AssertNoError(t, err)
	}
	testutil.AssertTrue(t, info.Mode()&0111 != 0, "Install script should be executable")
}

func TestDirectExecutor_DryRun(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-dryrun")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create execution context
	p, err := paths.New("")
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:  p,
		DryRun: true, // Enable dry run
		Config: config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create actions
	targetFile := filepath.Join(p.DataDir(), "test.txt")
	actions := []types.Action{
		{
			Type:        types.ActionTypeWrite,
			Description: "Write test file",
			Target:      targetFile,
			Content:     "This should not be written",
			Pack:        "test",
			HandlerName: "test",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// Verify file was NOT created
	testutil.AssertFalse(t, testutil.FileExists(t, targetFile), "File should not exist in dry run")
}

func TestDirectExecutor_ValidationErrors(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-validation")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create a source file in dotfiles directory
	testutil.CreateFile(t, dotfilesDir, "vimrc", "\" Test vimrc")
	sourceFile := filepath.Join(dotfilesDir, "vimrc")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: false, // Disable home symlinks
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create action that should fail validation
	// Source is valid (from dotfiles) but target is in home directory with home symlinks disabled
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link to home directory (should fail)",
			Source:      sourceFile,
			Target:      filepath.Join(homeDir, ".vimrc"),
			Pack:        "vim",
			HandlerName: "symlink",
			Priority:    100,
		},
	}

	// Execute - should fail validation
	_, err = executor.ExecuteActions(actions)
	testutil.AssertError(t, err)
	testutil.AssertErrorContains(t, err, "outside dodot-controlled directories")

	// Test protected system file validation
	t.Run("protected_system_file", func(t *testing.T) {
		// Allow home symlinks but try to write to protected file
		opts.AllowHomeSymlinks = true
		executor := NewDirectExecutor(opts)

		actions := []types.Action{
			{
				Type:        types.ActionTypeLink,
				Description: "Link to SSH key (should fail)",
				Source:      sourceFile,
				Target:      filepath.Join(homeDir, ".ssh/id_rsa"),
				Pack:        "ssh",
				HandlerName: "symlink",
				Priority:    100,
			},
		}

		_, err := executor.ExecuteActions(actions)
		testutil.AssertError(t, err)
		testutil.AssertErrorContains(t, err, "cannot modify protected system file")
	})

	// Test write action to protected path
	t.Run("write_to_protected_path", func(t *testing.T) {
		opts.AllowHomeSymlinks = true
		executor := NewDirectExecutor(opts)

		actions := []types.Action{
			{
				Type:        types.ActionTypeWrite,
				Description: "Write to AWS credentials (should fail)",
				Target:      filepath.Join(homeDir, ".aws/credentials"),
				Content:     "malicious content",
				Pack:        "aws",
				HandlerName: "config",
				Priority:    100,
			},
		}

		_, err := executor.ExecuteActions(actions)
		testutil.AssertError(t, err)
		testutil.AssertErrorContains(t, err, "cannot modify protected system file")
	})
}

func TestDirectExecutor_RepeatedDeploy(t *testing.T) {
	// Test that repeated deploys work without conflicts
	tempDir := testutil.TempDir(t, "direct-executor-repeated-deploy")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file
	testutil.CreateFile(t, dotfilesDir, "vimrc", "\" Test vimrc")
	sourceFile := filepath.Join(dotfilesDir, "vimrc")
	targetFile := filepath.Join(homeDir, ".vimrc")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create symlink action
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link .vimrc to home directory",
			Source:      sourceFile,
			Target:      targetFile,
			Pack:        "vim",
			HandlerName: "symlink",
			Priority:    100,
		},
	}

	// First deploy - should succeed
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, len(results) > 0, "Should have results")

	// Verify symlink was created
	info, err := os.Lstat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, info.Mode()&os.ModeSymlink != 0, "Target should be a symlink")

	// Second deploy - should also succeed (idempotent)
	results2, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, len(results2) > 0, "Should have results")

	// Verify symlink still exists and is correct
	info2, err := os.Lstat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, info2.Mode()&os.ModeSymlink != 0, "Target should still be a symlink")

	// Now test the case where user removes the target symlink
	err = os.Remove(targetFile)
	testutil.AssertNoError(t, err)

	// Third deploy - should recreate the symlink
	results3, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, len(results3) > 0, "Should have results")

	// Verify symlink was recreated
	info3, err := os.Lstat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, info3.Mode()&os.ModeSymlink != 0, "Target should be a symlink again")
}

func TestDirectExecutor_ConflictWithIdenticalFile(t *testing.T) {
	// Test that we can replace a regular file with symlink if content is identical
	tempDir := testutil.TempDir(t, "direct-executor-identical-file")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file and identical target file
	vimrcContent := "\" Test vimrc\nset number\nset autoindent"
	testutil.CreateFile(t, dotfilesDir, "vimrc", vimrcContent)
	testutil.CreateFile(t, homeDir, ".vimrc", vimrcContent) // Same content
	sourceFile := filepath.Join(dotfilesDir, "vimrc")
	targetFile := filepath.Join(homeDir, ".vimrc")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false, // Not using force
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create symlink action
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link .vimrc to home directory",
			Source:      sourceFile,
			Target:      targetFile,
			Pack:        "vim",
			HandlerName: "symlink",
			Priority:    100,
		},
	}

	// Deploy should succeed because content is identical
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, len(results) > 0, "Should have results")

	// Verify file was replaced with symlink
	info, err := os.Lstat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, info.Mode()&os.ModeSymlink != 0, "Target should now be a symlink")
}

func TestDirectExecutor_DeploymentMetadata(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-metadata")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file
	testutil.CreateFile(t, dotfilesDir, "bashrc", "# Test bashrc")
	sourceFile := filepath.Join(dotfilesDir, "bashrc")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create a simple symlink action
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link .bashrc",
			Source:      sourceFile,
			Target:      filepath.Join(homeDir, ".bashrc"),
			Pack:        "shell",
			HandlerName: "symlink",
			Priority:    100,
		},
	}

	// Execute
	_, err = executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)

	// Verify deployment metadata was written
	metadataPath := filepath.Join(p.DataDir(), "deployment-metadata")
	testutil.AssertTrue(t, testutil.FileExists(t, metadataPath), "Deployment metadata should exist")

	// Read and verify content
	content, err := os.ReadFile(metadataPath)
	testutil.AssertNoError(t, err)

	expectedContent := fmt.Sprintf("# Generated by dodot during deployment\n"+
		"# This file is sourced by dodot-init.sh\n"+
		"DODOT_DEPLOYMENT_ROOT=\"%s\"\n", dotfilesDir)

	testutil.AssertEqual(t, expectedContent, string(content))
}

func TestDirectExecutor_ConflictWithDifferentFile(t *testing.T) {
	// Test that we fail when target exists with different content (without force)
	tempDir := testutil.TempDir(t, "direct-executor-different-file")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file and different target file
	testutil.CreateFile(t, dotfilesDir, "vimrc", "\" New vimrc content")
	testutil.CreateFile(t, homeDir, ".vimrc", "\" Old vimrc content - different!")
	sourceFile := filepath.Join(dotfilesDir, "vimrc")
	targetFile := filepath.Join(homeDir, ".vimrc")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             false, // Not using force
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create symlink action
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Link .vimrc to home directory",
			Source:      sourceFile,
			Target:      targetFile,
			Pack:        "vim",
			HandlerName: "symlink",
			Priority:    100,
		},
	}

	// Deploy should fail because content is different
	_, err = executor.ExecuteActions(actions)
	testutil.AssertError(t, err)
	testutil.AssertErrorContains(t, err, "already exists as a regular file")
}

func TestDirectExecutor_ForceMode(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-force")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create source file and existing target
	testutil.CreateFile(t, dotfilesDir, "vimrc", "\" New vimrc")
	testutil.CreateFile(t, homeDir, ".vimrc", "\" Old vimrc")
	sourceFile := filepath.Join(dotfilesDir, "vimrc")
	targetFile := filepath.Join(homeDir, ".vimrc")

	// Create execution context with force mode
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		Force:             true, // Enable force mode
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	// Create executor
	executor := NewDirectExecutor(opts)

	// Create symlink action
	actions := []types.Action{
		{
			Type:        types.ActionTypeLink,
			Description: "Force link .vimrc to home directory",
			Source:      sourceFile,
			Target:      targetFile,
			Pack:        "vim",
			HandlerName: "symlink",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, len(results) > 0, "Should have results")

	// Verify symlink was created (replacing the existing file)
	info, err := os.Lstat(targetFile)
	testutil.AssertNoError(t, err)
	testutil.AssertTrue(t, info.Mode()&os.ModeSymlink != 0, "Target should be a symlink")
}

func TestDirectExecutor_BrewAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-brew")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/homebrew")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create a Brewfile
	brewfileContent := `tap "homebrew/cask"
brew "git"
brew "vim"
cask "visual-studio-code"`
	testutil.CreateFile(t, dotfilesDir, "Brewfile", brewfileContent)
	brewfile := filepath.Join(dotfilesDir, "Brewfile")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            true, // Use dry run to avoid actually running brew
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create brew action with checksum metadata
	actions := []types.Action{
		{
			Type:        types.ActionTypeBrew,
			Description: "Install packages from Brewfile",
			Source:      brewfile,
			Pack:        "homebrew",
			HandlerName: "homebrew",
			Priority:    90,
			Metadata: map[string]interface{}{
				"pack":     "homebrew",
				"checksum": "abc123", // Mock checksum
			},
		},
	}

	// Execute in dry run mode
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)
}

func TestDirectExecutor_InstallAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-install")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create an install script that creates a marker file
	installScript := `#!/bin/bash
echo "Installing tools..."
mkdir -p "$HOME/.local/test"
echo "installed" > "$HOME/.local/test/marker.txt"
echo "Done!"`
	testutil.CreateFile(t, dotfilesDir, "install.sh", installScript)
	scriptPath := filepath.Join(dotfilesDir, "install.sh")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create install action
	actions := []types.Action{
		{
			Type:        types.ActionTypeInstall,
			Description: "Run install script",
			Source:      scriptPath,
			Pack:        "tools",
			HandlerName: "install_script",
			Priority:    90,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// Verify script was copied to install directory (with pack name)
	targetScript := filepath.Join(p.InstallDir(), "tools", "install.sh")
	testutil.AssertTrue(t, testutil.FileExists(t, targetScript), "Install script should be copied")

	// Verify sentinel file was created
	sentinelPath := p.SentinelPath("install", "tools")
	testutil.AssertTrue(t, testutil.FileExists(t, sentinelPath), "Sentinel file should exist")

	// Verify the install script was actually executed by checking for the marker file
	markerPath := filepath.Join(homeDir, ".local", "test", "marker.txt")
	testutil.AssertTrue(t, testutil.FileExists(t, markerPath), "Install script should have created marker file")

	// Verify marker file content
	content, err := os.ReadFile(markerPath)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, "installed\n", string(content))
}

func TestDirectExecutor_AppendAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-append")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create an existing file to append to
	existingContent := "# Existing content\n"
	targetFile := filepath.Join(homeDir, ".bashrc")
	testutil.CreateFile(t, homeDir, ".bashrc", existingContent)

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create append action
	appendContent := "\n# Added by dodot\nexport PATH=$PATH:/usr/local/bin\n"
	actions := []types.Action{
		{
			Type:        types.ActionTypeAppend,
			Description: "Append to .bashrc",
			Target:      targetFile,
			Content:     appendContent,
			Pack:        "shell",
			HandlerName: "shell_profile",
			Priority:    80,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// Verify content was appended
	content := testutil.ReadFile(t, targetFile)
	testutil.AssertContains(t, content, existingContent)
	testutil.AssertContains(t, content, appendContent)
	testutil.AssertEqual(t, existingContent+appendContent, content)
}

func TestDirectExecutor_ShellSourceAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-shellsource")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create a shell script to source
	shellScript := `# Custom shell functions
function myfunc() {
    echo "Hello from myfunc"
}`
	testutil.CreateFile(t, dotfilesDir, "functions.sh", shellScript)
	scriptPath := filepath.Join(dotfilesDir, "functions.sh")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create shell source action
	actions := []types.Action{
		{
			Type:        types.ActionTypeShellSource,
			Description: "Source shell functions",
			Source:      scriptPath,
			Pack:        "shell",
			HandlerName: "shell_profile",
			Priority:    80,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// Verify source command was added to shell init file
	shellInitFile := filepath.Join(p.ShellDir(), "init.sh")
	testutil.AssertTrue(t, testutil.FileExists(t, shellInitFile), "Shell init file should exist")
	content := testutil.ReadFile(t, shellInitFile)
	testutil.AssertContains(t, content, "source \""+scriptPath+"\"")
}

func TestDirectExecutor_PathAddAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-pathadd")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/path")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create a bin directory to add to PATH
	binDir := filepath.Join(dotfilesDir, "bin")
	testutil.CreateDir(t, dotfilesDir, "bin")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create path add action
	actions := []types.Action{
		{
			Type:        types.ActionTypePathAdd,
			Description: "Add bin directory to PATH",
			Target:      binDir,
			Pack:        "tools",
			HandlerName: "path",
			Priority:    90,
			Metadata: map[string]interface{}{
				"dirName": "bin",
			},
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// Verify symlink was created in deployed/path
	deployedLink := filepath.Join(p.DeployedDir(), "path", "tools-bin")

	// Check if it's a symlink (FileExists might not work for broken symlinks)
	if _, err := os.Lstat(deployedLink); err != nil {
		t.Fatalf("Deployed path symlink should exist: %v", err)
	}

	// Verify symlink points to the right directory
	target, err := os.Readlink(deployedLink)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, binDir, target)

	// Verify PATH export was added to shell init file
	shellInitFile := filepath.Join(p.ShellDir(), "init.sh")
	testutil.AssertTrue(t, testutil.FileExists(t, shellInitFile), "Shell init file should exist")
	content := testutil.ReadFile(t, shellInitFile)
	testutil.AssertContains(t, content, "export PATH=\""+deployedLink+":$PATH\"")
}

func TestDirectExecutor_PathAddAction_Idempotent(t *testing.T) {
	// This test ensures that running path add actions multiple times doesn't fail
	// Regression test for issue #523 where second install would fail with "symlink already exists"

	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-path-idempotent")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create a bin directory with executable
	testutil.CreateDir(t, dotfilesDir, "tools")
	testutil.CreateDir(t, dotfilesDir, "tools/bin")
	testutil.CreateFile(t, dotfilesDir, "tools/bin/mytool", "#!/bin/bash\necho 'mytool'")
	binDir := filepath.Join(dotfilesDir, "tools", "bin")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create path add action
	actions := []types.Action{
		{
			Type:        types.ActionTypePathAdd,
			Description: "Add bin directory to PATH",
			Target:      binDir,
			Pack:        "tools",
			HandlerName: "path",
			Priority:    90,
			Metadata: map[string]interface{}{
				"dirName": "bin",
			},
		},
	}

	// Execute first time - should succeed
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// Verify symlink was created
	deployedLink := filepath.Join(p.DeployedDir(), "path", "tools-bin")
	// Check if it's a symlink (FileExists might not work for broken symlinks)
	if _, err := os.Lstat(deployedLink); err != nil {
		t.Fatalf("Deployed path symlink should exist: %v", err)
	}

	// Execute second time - should also succeed (idempotent)
	results2, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results2))
	testutil.AssertEqual(t, types.StatusReady, results2[0].Status)

	// Verify symlink still exists and points to the same target
	target, err := os.Readlink(deployedLink)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, binDir, target)

	// Execute third time with a different source directory - should update
	newBinDir := filepath.Join(dotfilesDir, "newtools", "bin")
	testutil.CreateDir(t, dotfilesDir, "newtools")
	testutil.CreateDir(t, dotfilesDir, "newtools/bin")

	actions[0].Target = newBinDir
	results3, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results3))
	testutil.AssertEqual(t, types.StatusReady, results3[0].Status)

	// Verify symlink now points to new target
	newTarget, err := os.Readlink(deployedLink)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, newBinDir, newTarget)
}

func TestDirectExecutor_ReadAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-read")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create a test file to read
	testContent := "This is test content\nWith multiple lines\n"
	testutil.CreateFile(t, dotfilesDir, "testfile.txt", testContent)
	testFile := filepath.Join(dotfilesDir, "testfile.txt")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Create read action
	actions := []types.Action{
		{
			Type:        types.ActionTypeRead,
			Description: "Read test file",
			Source:      testFile,
			Pack:        "test",
			HandlerName: "test",
			Priority:    100,
		},
	}

	// Execute
	results, err := executor.ExecuteActions(actions)
	testutil.AssertNoError(t, err)
	testutil.AssertEqual(t, 1, len(results))
	testutil.AssertEqual(t, types.StatusReady, results[0].Status)

	// The Read operation stores outputs that could be retrieved later
	// In a real scenario, the synthfs result would contain the file content
}

func TestDirectExecutor_ChecksumAction(t *testing.T) {
	// Setup test environment
	tempDir := testutil.TempDir(t, "direct-executor-checksum")
	dotfilesDir := filepath.Join(tempDir, "dotfiles")
	homeDir := filepath.Join(tempDir, "home")

	testutil.CreateDir(t, tempDir, "dotfiles")
	testutil.CreateDir(t, tempDir, "home")
	testutil.CreateDir(t, homeDir, ".local/share/dodot")
	testutil.CreateDir(t, homeDir, ".local/share/dodot/deployed/symlink")

	t.Setenv("HOME", homeDir)
	t.Setenv("DOTFILES_ROOT", dotfilesDir)
	t.Setenv("DODOT_DATA_DIR", filepath.Join(homeDir, ".local", "share", "dodot"))

	// Create a test file to checksum
	testContent := "This is test content for checksum\n"
	testutil.CreateFile(t, dotfilesDir, "checkfile.txt", testContent)
	testFile := filepath.Join(dotfilesDir, "checkfile.txt")

	// Create execution context
	p, err := paths.New(dotfilesDir)
	testutil.AssertNoError(t, err)

	opts := &DirectExecutorOptions{
		Paths:             p,
		DryRun:            false,
		AllowHomeSymlinks: true,
		Config:            config.Default(),
	}

	executor := NewDirectExecutor(opts)

	// Test different algorithms
	algorithms := []string{"md5", "sha1", "sha256", "sha512"}

	for _, alg := range algorithms {
		t.Run(alg, func(t *testing.T) {
			// Create checksum action
			actions := []types.Action{
				{
					Type:        types.ActionTypeChecksum,
					Description: fmt.Sprintf("Calculate %s checksum", alg),
					Source:      testFile,
					Pack:        "test",
					HandlerName: "test",
					Priority:    100,
					Metadata: map[string]interface{}{
						"algorithm": alg,
					},
				},
			}

			// Execute
			results, err := executor.ExecuteActions(actions)
			testutil.AssertNoError(t, err)
			testutil.AssertEqual(t, 1, len(results))
			testutil.AssertEqual(t, types.StatusReady, results[0].Status)
		})
	}

	// Test with default algorithm (no metadata)
	t.Run("default_algorithm", func(t *testing.T) {
		actions := []types.Action{
			{
				Type:        types.ActionTypeChecksum,
				Description: "Calculate checksum with default algorithm",
				Source:      testFile,
				Pack:        "test",
				HandlerName: "test",
				Priority:    100,
			},
		}

		// Execute
		results, err := executor.ExecuteActions(actions)
		testutil.AssertNoError(t, err)
		testutil.AssertEqual(t, 1, len(results))
		testutil.AssertEqual(t, types.StatusReady, results[0].Status)
	})
}
