Docker Integration Testing Environment
======================================

This directory contains a Docker-based testing environment for dodot that allows
safe testing of file operations in an isolated Ubuntu environment.

Architecture Overview
---------------------

CRITICAL: The host (macOS ARM64) and container (Linux) have different 
architectures. You CANNOT mount a pre-built binary from the host. The binary
MUST be compiled inside the container.

The testing infrastructure follows a three-phase execution model:

1. **Docker Image (Dockerfile)**
   - Bakes in OS-level dependencies: Ubuntu, Go, Homebrew, git, etc.
   - Creates cached filesystem layers for fast rebuilds
   - Does NOT include dodot source code or scripts

2. **Runtime Mounting**
   - Entire repository mounted at runtime (not copied, not baked)
   - Allows testing live code changes without image rebuilds
   - All scripts mounted for easy modification

3. **Three-Phase Execution**
   - Setup Phase: Build dodot-container-linux binary inside container
   - Test Phase: Execute integration tests using fresh binary
   - Report Phase: Collect test output and dodot logs

Quick Start
-----------

1. Build Docker image (one-time setup):
   $ docker build -t dodot-test .

2. Run complete test suite:
   $ ./docker-run.sh

That's it! The docker-run.sh script handles everything else.

How It Works
------------

The docker-run.sh script:
- Mounts the entire repository into the container
- Runs orchestrator.sh which executes three phases in order:
  1. setup.sh - Compiles dodot-container-linux binary
  2. test.sh - Runs integration test suite
  3. report.sh - Collects and formats results

This structure ensures:
- Fast iteration: Change code, immediately test
- Clear architecture: No binary compatibility confusion  
- Easy debugging: Modify individual phase scripts
- Stable interface: docker-run.sh never changes

Directory Structure
-------------------

- Dockerfile: Ubuntu image with Go, Homebrew, and tools
- docker-run.sh: Stable entry point (rarely modified)
- orchestrator.sh: Runs the three phases in sequence
- scripts/
  - setup.sh: Builds dodot binary inside container
  - test.sh: Executes integration tests
  - report.sh: Collects logs and formats output
- sample-dotfiles/: Test data representing real usage

Milestones
----------

**Milestone 1: Running the Tests** (Current)
- Set up container with proper build environment
- Compile dodot inside container on each run
- Execute basic test suite
- Ensure architecture compatibility

**Milestone 2: Useful Test Reporting**
- Capture test results with detailed output
- Include dodot logs in reports
- Structured reporting format
- Easy debugging without container access

**Milestone 3: CI Integration**
- GitHub Actions workflow
- Automated testing on PRs
- Matrix testing across Ubuntu versions
- Performance benchmarking

Important Notes
---------------

1. NEVER try to mount a pre-built binary - it won't work across architectures
2. The docker image only contains OS dependencies, not application code
3. All dodot code and scripts are mounted at runtime
4. The first thing setup.sh does is compile the binary
5. Binary is named dodot-container-linux to avoid confusion
6. Modify phase scripts (setup/test/report), not docker-run.sh

This design prioritizes fast development cycles and clear separation of concerns
while providing a safe environment for aggressive file system testing.